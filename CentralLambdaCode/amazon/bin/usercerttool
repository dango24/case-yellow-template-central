#!/System/Library/Frameworks/Python.framework/Versions/Current/bin/python

## usercerttool
## Written by Gerrit DeWitt (gerritd@amazon.com)
## Modified by Jason Simmons (jasosimm@amazon.com)
## Version 2.9.8.5 - 2018-10-25 Copyright Amazon

import os, pwd, sys, time, datetime, uuid
sys.path.insert(0,'/usr/local/amazon/libexec/acme')
from common_acme import *
from common_acme_crypto import *

## SUBROUTINES

def azShowToolHelp():
## Displays syntax help.
	print '''
-------
User Certificate Tool (usercerttool): Gets the status of, configures, or removes a user certificate.
Version 2.9.8.4d Copyright Amazon
https://w.amazon.com/index.php/ClientEng/Mac/AssistantsAndAutomations
-------
USAGE: usercerttool status | configure [email] | remove [email] | remove-old-wifi-ids
status: Returns the status of the user's certificate.
configure: Creates the configuration profile with the user's certificate.
remove: Removes the configuration profile with the user's certificate.
email: Optional additional parameter: Create a certificate based on the Amazon User Email template.
remove-old-wifi-ids: Removes old identity prefs for user certificate Wi-Fi configuration.
-------
Possible states for the user's certificate are:
1.  ok: a configuration profile with the user's certificate was found.
2.  expiring: the user's certificate (from the configuration profile) will soon expire.
3.  expired: the user's certificate (from the configuration profile) has expired.
4.  not-found: missing a configuration profile with the user's certificate.
-------
NOTES:
1.  This tool requires that the computer be bound to Active Directory.
2.  Only cached accounts from Active Directory are eligible users.
3.  This tool should be run by the user for whom the certificate is to be created.
4.  Creating an user certificate requires a valid Kerberos Ticket for the user.
5.  Use of the create verb is limited to states 2-4.
-------
'''

def validateArgs():
## Validates arguments, and returns true/false.
	argsValid = False
	action = ''
	useEmailOption = False
	# Check args:
	if len(sys.argv) == 2 or len(sys.argv) == 3:
		# Define and validate action:
		action = sys.argv[1]
		if ( action == 'status' or action == 'configure' or action == 'remove' or action == 'remove-old-wifi-ids'):
			argsValid = True
			if len(sys.argv) == 3:
				if sys.argv[2] == 'email':
					useEmailOption = True
				else:
					argsValid = False
	# Return:
	return argsValid, action, useEmailOption

def checkForUserCertProfile(requestedUser, useEmailOption):
## Determines if the mobileconfig file for the user identity is installed.
## Extracts expiry date for certificate.
	# Defaults:
	profileIsInstalled = False
	if useEmailOption:
		expectedProfileIdentifier = "com.amazon.profile.emailCertificate." + str(requestedUser)
		expectedPayloadIdentifierPrefix = "com.amazon.profile.payload.security.pkcs12.email." + str(requestedUser) + "."
	else:
		expectedProfileIdentifier = "com.amazon.profile.userCertificate." + str(requestedUser)
		expectedPayloadIdentifierPrefix = "com.amazon.profile.payload.security.pkcs12." + str(requestedUser) + "."
	profilePayloadArray = []
	userProfilesArray = listConfigurationProfilesForUser(requestedUser)
	# Default expiry date is now (for cases where the profile is not found):
	profileExpirationDate = datetime.datetime.utcnow()
	# Iterate through profiles:
	for profile in userProfilesArray:
		if profile['ProfileIdentifier'] == expectedProfileIdentifier:
			profilePayloadArray = profile['ProfileItems']
			break
	for payload in profilePayloadArray:
		if payload['PayloadIdentifier'].find(expectedPayloadIdentifierPrefix) != -1:
			profileIsInstalled = True
			profileExpirationDateStr = payload['PayloadIdentifier'].replace(expectedPayloadIdentifierPrefix,'').replace('Z','')
			profileExpirationDate = datetime.datetime.strptime(profileExpirationDateStr,'%Y%m%d%H%M%S')
	# Return:
	return profileIsInstalled, profileExpirationDate

def mainVerificationRoutine(requestedUser, useEmailOption):
# Determines status of the user's certificate: not-found, expiring, expired, ok.
	expirationThreshold = mainDictionary['certificateExtensionsDict']['expirationThreshold']
	# Defaults:
	status = "verification-in-progress"
	nowPoint = datetime.datetime.utcnow()
	expirationCheckPoint = nowPoint + datetime.timedelta(seconds=int(expirationThreshold))
	# Look for configuration profile:
	[profileIsInstalled, profileExpirationDate] = checkForUserCertProfile(requestedUser, useEmailOption)
	if not profileIsInstalled:
		logger.debug('Configuration profile containing user identity not found.')
		status = "not-found"
	else:
		# Check for expiring/expired profile:
		if profileExpirationDate < expirationCheckPoint:
			status = "expiring"
			if profileExpirationDate < nowPoint:
				status = "expired"
		else:
			status = "ok"
	# Return:
	return status, profileExpirationDate

def createAndInstallUserCertProfile(requestedUser, useEmailOption, p12Path, p12Password, certExpirationDate, configProfilePath):
## Create the mobileconfig profile with the user's identity.
	# Defaults:
	installedConfigProfile = False
	# Read p12Contents from p12Path:
	p12FileObj = open(p12Path,'r')
	p12Contents = p12FileObj.read()
	p12FileObj.close()
	if not p12Contents:
		logger.error('createAndInstallUserCertProfile: Could not read PKCS12 contents.')
	else:
		# Array of payloads for profile:
		profilePayloadArray = []
		# Generate UUID for the certificate payload:
		userCertificatePayloadUuid = str(uuid.uuid1()).upper()
		# Various prefixes:
		if useEmailOption:
			prefixPayloadIdentifier = "com.amazon.profile.payload.security.pkcs12.email."
			payloadDescription = "For email encryption and signing."
			prefixDisplayName = "Email Certificate ("
			prefixProfileIdentifier = "com.amazon.profile.emailCertificate."
			payloadDescription = "Used for email encryption and signing."
		else:
			prefixPayloadIdentifier = "com.amazon.profile.payload.security.pkcs12."
			payloadDescription = "For VPN access and identity services."
			prefixDisplayName = "User Certificate ("
			prefixProfileIdentifier = "com.amazon.profile.userCertificate."
			payloadDescription = "Authentication for various services."
		# Populate certificate payload:
		payloadCertDict = {}
		payloadCertDict['PayloadContent'] = plistlib.Data(p12Contents)
		payloadCertDict['PayloadUUID'] = userCertificatePayloadUuid
		payloadCertDict['Password'] = p12Password
		payloadCertDict['PayloadType'] = "com.apple.security.pkcs12"
		payloadCertDict['PayloadVersion'] = int(1)
		payloadCertDict['PayloadIdentifier'] = prefixPayloadIdentifier + str(requestedUser) + "." + str(certExpirationDate)
		payloadCertDict['PayloadDescription'] = payloadDescription
		payloadCertDict['PayloadOrganization'] = "Amazon"
		payloadCertDict['PayloadDisplayName'] = prefixDisplayName + str(requestedUser) +")"
		payloadCertDict['PayloadEnabled'] = True
		payloadCertDict['SetupModes'] = ["User"]
		payloadCertDict['AllowAllAppsAccess'] = True
		payloadCertDict['KeyIsExtractable'] = False
		# Add certificate payload to profilePayloadArray:
		profilePayloadArray.append(payloadCertDict)
		# Generate UUID for the certificate payload:
		userCertificateProfileUUID = str(uuid.uuid1()).upper()
		# Populate profile:
		profileDict = {}
		profileDict['PayloadContent'] = profilePayloadArray
		profileDict['PayloadUUID'] = userCertificateProfileUUID;
		profileDict['PayloadType'] = "Configuration"
		profileDict['PayloadVersion'] = int(1)
		profileDict['PayloadIdentifier'] = prefixProfileIdentifier + str(requestedUser)
		profileDict['PayloadDescription'] = payloadDescription
		profileDict['PayloadOrganization'] = "Amazon"
		profileDict['PayloadDisplayName'] = prefixDisplayName + str(requestedUser) +")"
		profileDict['PayloadScope'] = "User"
		profileDict['PayloadRemovalDisallowed'] = False
		# Write profileDict to configuration profile:
		azWritePlist(profileDict, configProfilePath)
		# Install configuration profile:
		installedConfigProfile = installConfigurationProfile(configProfilePath)
	# Return:
	return installedConfigProfile

def mainConfigurationRoutine(requestedUser,useEmailOption,certTemplate,configProfilePath,pKeyPath,reqPath,p12Path):
# Overall configuration process for creating user certificate:
# 1. Generates a machine key and certificate request - generateCSR().
# 2. Submits CSR to a certificate server for signing and receives certificate - uploadCSRAndDownloadSignedCert().
# 3. Creates a pkcs12 file - createPKCS12().
# 4. Configures user identity - createAndInstallUserCertProfile().
	openSSLDict = mainDictionary['openSSLConf']
	keyBits = int( mainDictionary['identityDetailsDict']['keyBits'] )
	keyHash = str( mainDictionary['identityDetailsDict']['keyHash'] )
	caRequestDetailsDict = mainDictionary['caRequestDetailsDict']
	identityNameRecipe =  mainDictionary['identityDetailsDict']['identityNameRecipe']

	# Default:
	configurationComplete = False
	problem = 'no-problem'
	# Generate private key and certificate request:
	logger.info('Generating private key and certificate request.')
	if not generateCSR(requestedUser, openSSLDict, keyBits, keyHash, pKeyPath, reqPath):
		logger.error('Could not generate certificate request.')
		problem = 'could-not-generate-csr'
	else:
		# Upload certificate request:
		logger.info('Uploading certificate request.')
		[uploadResult, certificateResult] = uploadCSRAndDownloadSignedCert(caRequestDetailsDict, certTemplate, reqPath)
		if not uploadResult:
			logger.error('Could not upload certificate request.')
			problem = 'could-not-upload-csr'
		else:
			# Create pkcs12:
			logger.info('Creating p12.')
			friendlyName = identityNameRecipe.replace('__userName__',requestedUser)
			[havePkcs12,certExpirationDate,p12Password] = createPKCS12(friendlyName, certificateResult, pKeyPath, p12Path) 
			if not havePkcs12:
				logger.error('Problem downloading certificate or creating p12.')
				problem = 'could-not-download-or-create-p12'
			else:
				# Create and import configuration profile:
				logger.info('Configuring user certificate.')
				configurationComplete = createAndInstallUserCertProfile(requestedUser, useEmailOption, p12Path, p12Password, certExpirationDate, configProfilePath)
				if not configurationComplete:
					logger.error('Could not configure user certificate.')
					problem = 'could-not-configure-user-certificate'
				else:
					logger.info('Configuration complete.')
	# Return:
	return configurationComplete, problem

def main():
## MAIN
	# Open mainDictionary:
	global mainDictionary
	mainDictionary = azLoadMainDictionary()
	adDomain = mainDictionary['adDomain']
	adDomainSearchPath = mainDictionary['adDomainSearchPath']	
	# Parse args:
	[argsValid, action, useEmailOption] = validateArgs()
	if not argsValid:
		azShowToolHelp()
	else:
		# Validate the user:
		[haveValidUser, requestedUser, userHomePath] = validateUser(adDomain)
		pKeyPath = mainDictionary['privateKeyPath'].replace('~',userHomePath).replace('__azIdentifier__',azIdentifier)
		reqPath = mainDictionary['certRequestPath'].replace('~',userHomePath).replace('__azIdentifier__',azIdentifier)
		p12Path = mainDictionary['p12FilePath'].replace('~',userHomePath).replace('__azIdentifier__',azIdentifier)
		configProfilePath = mainDictionary['configProfilePath'].replace('~',userHomePath).replace('__azIdentifier__',azIdentifier)
		if useEmailOption:
			certTemplate = mainDictionary['caRequestDetailsDict']['emailCertTemplate']
		else:
			certTemplate = mainDictionary['caRequestDetailsDict']['userCertTemplate']
		identityPrefRemovalsList = mainDictionary['identityPrefRemovalsList']

		# Default states for other variables we write:
		problem = 'no-problem'
		lastCheck = datetime.datetime.utcnow()
		if not haveValidUser:
			# Invalid user.
			logger.error('Requested user (' + requestedUser + ') is not a cached account from Active Directory.')
			problem = 'invalid-user'
		else:		
			# Clean up file paths:
			ensureDeleted([pKeyPath, reqPath, p12Path, configProfilePath])
			# Initial verification:
			[status, profileExpirationDate] = mainVerificationRoutine(requestedUser, useEmailOption)
			logger.info('User certificate status: ' + status)
			# Report expiration date if certificate present:
			if status != 'not-found':
				logger.info('Certificate expiration date: ' + str(profileExpirationDate))
			# Configuration or removal:
			if action != 'status':
				# Clean up file paths:
				ensureDeleted([pKeyPath, reqPath, p12Path, configProfilePath])
				# Defaults - configuration or removal:
				configurationSuccessful = False
				removalSuccessful = False
				# REMOVE OLD WI-FI IDS: Attempt to remove old identity prefs for user domain Wi-Fi config.
				if action == 'remove-old-wifi-ids':
					removeIdentityPrefsFromKeychain(identityPrefRemovalsList)
					logger.info('Removed identity prefs for old Wi-Fi configuration.')
				# CONFIGURE:
				elif action == 'configure':
					if status == 'ok':
						logger.info('A configuration profile for the user certificate already exists.')
					else:
						# Check for Kerberos TGT.
						if not userHasTGT(requestedUser,adDomain):
							problem = 'missing-tgt'
							logger.error('Missing TGT for user.  Renew Kerberos ticket and try again.')
						else:
							# Determine PDC domain controller:
							domainController = findDomainController(adDomain)
							if domainController == 'invalid':
								problem = 'could-not-determine-pdc'
								logger.error('Could not find a PDC.  Is this computer on the Amazon network?  Are DNS search domains correct?')
							else:
								logger.debug('Domain controller is: ' + domainController)
								# Attempt to create a config profile with the user identity:
								logger.info('Running configuration routine.')
								[configurationSuccessful, problem] = mainConfigurationRoutine(requestedUser,useEmailOption,certTemplate,configProfilePath,pKeyPath,reqPath,p12Path)
								if not configurationSuccessful:
									logger.error('Problem running main configuration routine.' )
	
				# REMOVE:
				if action == 'remove':
					logger.info('Running routine to remove the configuration profile with the user certificate.')
					# Profile prefix for removal:
					if useEmailOption:
						prefixProfileIdentifier = "com.amazon.profile.emailCertificate."
					else:
						prefixProfileIdentifier = "com.amazon.profile.userCertificate."
					# Remove profile:
					[removalSuccessful, problem] = removeConfigurationProfile(prefixProfileIdentifier+str(requestedUser))
					if not removalSuccessful:
						logger.error('Problem running routine to remove the configuration profile.')
				# Secondary verification after successful configuration or removal:
				if configurationSuccessful or removalSuccessful:
					[status, profileExpirationDate] = mainVerificationRoutine(requestedUser, useEmailOption)
					if not (action == 'configure' and status == 'ok') and not (action == 'remove' and status == 'not-found'):
						logger.error('Secondary verification procedure failed.' )
					else:
						logger.info('User certificate status: ' + status)
						if status != 'not-found':
							logger.info('Certificate expiration date: ' + str(profileExpirationDate))
		# Update prefs.
		# Preference file is always user domain.
		if useEmailOption:
			# Prefs file is com.amazon.acme.usercerttool.email:
			assistantPrefsPath = mainDictionary['prefsFile'].replace('~',userHomePath).replace('__azIdentifier__',azIdentifier+'.email')
		else:
			assistantPrefsPath = mainDictionary['prefsFile'].replace('~',userHomePath).replace('__azIdentifier__',azIdentifier)
		try:
			assistantPrefsDict = azReadPlist(assistantPrefsPath)
		except:
			assistantPrefsDict = {}
		# These keys may be missing if there's a problem:
		try:
			assistantPrefsDict['expirationDate'] = profileExpirationDate
			assistantPrefsDict['lastCheck'] = lastCheck
			assistantPrefsDict['status'] = status
		except:
			logger.debug('No status information.' )
		# Problem key should always be present:
		assistantPrefsDict['problem'] = problem
		# Write prefs file:
		azWritePlist(assistantPrefsDict, assistantPrefsPath)
		# Clean up file paths:
		ensureDeleted([pKeyPath, reqPath, p12Path, configProfilePath])

if __name__ == '__main__':
	global azIdentifier
	global logger
	
	azIdentifier = 'com.amazon.acme.usercerttool'
	logger = azLogger(azIdentifier)
	try:
		main()
	except:
		logger.error('Generic exception.')
