#!/System/Library/Frameworks/Python.framework/Versions/Current/bin/python

## Mac Quarantine: quarantine
## Copyright Amazon
## Written by Gerrit DeWitt (gerritd@amazon.com)
## Updated by Jason Simmons (jasosimm@amazon.com)
## Update by LJ Cline (joscline@amazon.com)
## Version 1.5.0.6 - 2018-10-08
## Project started 2013-04-22

import subprocess, os, sys, syslog, math, time, httplib, shutil, plistlib
sys.path.insert(0,'/usr/local/amazon/libexec/quarantine')
from common_quarantine import *
import sys
sys.path.append('/usr/local/amazon/lib')
import systemprofile
import acme
import acme.ipc as ipc
import requests
import json

QUARANTINE_CONTROLLER_ENDPOINT = "https://{}/api/cert/quarantineController"
ACME_RUN_DIRECTORY = "/usr/local/amazon/var/acme/run"
REGISTRATION_CACHE_FILE_PATH = "/usr/local/amazon/var/acme/manifests/registration_data.json"

def readMainConfiguration():
## 1 - Reads main configuration file, setting globals (including paths where other files are stored). ##
## 2 - Computes path to parent output file (parentOutputPath), based on info from main configuration. ##
## 3 - Reads parentOutputPath, setting up dict for parent output (parentOutputDict). ##

	global mainConfigDict
	mainConfigDict = loadMainDictionary()
	
	global azProductIdentifier	
	azProductIdentifier = mainConfigDict['azProductIdentifier'] 

	global azModulesDir, azConfigDir, azModuleOutputDir
	azConfigDir = mainConfigDict['azConfigDir'] 
	azModulesDir = mainConfigDict['azModulesDir'] 
	azModuleOutputDir = mainConfigDict['azModuleOutputDir'] 
	
	global modulesConfigDict, enabledModules, disabledModules
	modulesConfigDict = plistlib.readPlist(azConfigDir+'/modules.plist')
	# Build enabledModules & disabledModules:
	enabledModules = azBuildModulesArray(modulesConfigDict, True)
	disabledModules = azBuildModulesArray(modulesConfigDict, False)

	# Determine parentOutputPath and read/init parentOutputDict:
	global parentOutputPath, parentOutputDict
	parentOutputPath = azModuleOutputDir + '/' + azIdentifier + '.plist'
	try:
		parentOutputDict = plistlib.readPlist(parentOutputPath)
	except:
		parentOutputDict = {}
	
## BEGIN: argsValid() ##
def argsValid():
# Default:
	argsAreValid = False
	
	if len(sys.argv) >= 2:
		if sys.argv[1] in ['evaluate','--runAll']:
			argsAreValid = True
							
		elif sys.argv[1] in ['moduleStatus','listModules']:
			showModuleStatus()

	return	argsAreValid

def evaluateModulesAndComputeParentState():
## Run and evaluate output of all modules.
## Calculate parent state, and set parent timelines accordingly.
	# newParentState: starts at 8 (no data; initial value):
	newParentState = 8
	# Array for failed modules: initial values.
	isoCandidatesModules=[]

	# Evaluate the modules:
	logger.info('Will evaluate %s modules.' % str(len(enabledModules)))
	for toolName in enabledModules:
		logger.info('Calling evaluation routine for %s.' % toolName)
		evaluateModule(toolName)

		# Update isolation reasons:
		if parentOutputDict[toolName]['moduleState'] == 0:
			isoCandidatesModules.append(toolName)
			logger.info( '%s is a reason for isolation.' % toolName)
		# Determine parent state and parent timeline.  Will be true at least once.
		if parentOutputDict[toolName]['moduleState'] <  newParentState:
			# Update newParentState: lowest of the modules (worst state is the winner).
			newParentState = parentOutputDict[toolName]['moduleState']
			logger.info('Calculated parent state is %s.' % str(newParentState))
			if newParentState == 7:
				# COMPLIANT: Remove parent timeline data if present.
				#logger.info('Removing parent timeline data...')
				try:
					del parentOutputDict['parentNcDate']
				except KeyError:
					pass
				try:
					del parentOutputDict['parentIcDate']
				except KeyError:
					pass
			else:
				# NON-COMPLIANT: Compute parent timeline data.
				# Reconcile non compliant date in parent timeline:
				logger.info('Calculating parent timeline data...')
				logger.info('-> Parent non-compliant date:')
				try:
					parentNcDate = parentOutputDict['parentNcDate']
					logger.info('->-> Existing: %s' % str(parentNcDate))
				except KeyError:
					parentNcDate = datetime.datetime.utcnow() + datetime.timedelta(days=365)
					logger.info('->-> Existing: No Data')
				try:
					logger.info('->-> From Module: %s' % str(parentOutputDict[toolName]['ncDate']))
				except KeyError:
					logger.info('->-> From Module: No Data')
				if parentOutputDict[toolName]['ncDate'] < parentNcDate:
					parentOutputDict['parentNcDate'] = parentOutputDict[toolName]['ncDate']
				logger.info('->-> Chosen: %s' % str(parentOutputDict['parentNcDate']))
				# Reconcile isolation candidate date in parent timeline:
				logger.info('-> Parent isolation candidate date:')
				try:
					parentIcDate = parentOutputDict['parentIcDate']
					logger.info('->-> Existing: %s' % str(parentIcDate))
				except KeyError:
					parentIcDate = datetime.datetime.utcnow() + datetime.timedelta(days=365)
					logger.info('->-> Existing: No Data')
				try:
					logger.info('->-> From Module: %s' % str(parentOutputDict[toolName]['icDate']))
				except KeyError:
					logger.info('->-> From Module: No Data')
				if parentOutputDict[toolName]['icDate'] < parentIcDate:
					parentOutputDict['parentIcDate'] = parentOutputDict[toolName]['icDate']
				logger.info('->-> Chosen: %s' % str(parentOutputDict['parentIcDate']))

		logger.info('Finished evaluating %s.' % toolName)

	logger.info('Done evaluating modules.')

	# Convert isoCandidatesModules array to string:
	isoCandidatesModules =  ','.join(isoCandidatesModules)
	# Return:
	return newParentState, isoCandidatesModules
		

def determineIsolationAction(newParentState, isoCandidatesModules):
## Compare the current parent state to the new parent state.  Update if appropriate.
## Return the appropriate action for entering isolation, reporting in-isolation, or exiting isolation.
	# Defaults:
	action = ''
	stateLabelsDict = mainConfigDict['stateLabelsDict']
	# Whether parent state changes or not, we can write the new parent state UNLESS
	# the old parent state was -1 (isolated) and the new parent state is 0 (isolation candidate).
	shouldReplaceParentState = True

	logger.info('Comparing previous parent state to calculated parent state.')
	# Read old parent state; if not present, use 8 (no data):
	try:
		oldParentState = parentOutputDict['parentState']
		logger.info('->-> Previous Parent State Value: %s' % str(oldParentState))
		logger.info('->-> Previous Parent State Label: %s' % str(stateLabelsDict[str(oldParentState)]))
	except KeyError:
		oldParentState = 8
		logger.info('->-> Previous Parent State: No Data')
	logger.info('->-> Calculated Parent State Value: %s' % str(newParentState))
	logger.info('->-> Calculated Parent State Label: %s' % str(stateLabelsDict[str(newParentState)]))

	# Actions if parent state changed:		
	if (newParentState == 7) and (oldParentState == -1):
		# Leaving isolation:
		logger.info('Returned to compliant from isolation.  Next action is connect.')
		action = 'connect'
	elif (newParentState == 0) and (oldParentState == -1):
		# Already in isolation; just report state.
		shouldReplaceParentState = False
		logger.info('Isolated. Keeping parent state at -1. Next action is update.')
		action = 'update'
	elif (newParentState == 0) and (oldParentState != -1):
		# Isolation candidate; not already isolated; request isolation:
		logger.info('Isolation candidate.  Next action is isolate.')
		action = 'isolate'
	elif (newParentState == 0) and (oldParentState == 0):
		# The only interesting case is oldParentState = newParentState = 0:
		# Need to ask for isolation permission again, because isolated would have oldParentState of -1.
		logger.info('Still an isolation candidate.  Next action is isolate.')
		action = 'isolate'

	# Write the new parent state:
	if shouldReplaceParentState:
		logger.info('Writing new parent state...')
		parentOutputDict['parentState'] = newParentState

	# Return action:
	return action

def getQuarantineControllerHost():
	server = ""
	try:
		with open(REGISTRATION_CACHE_FILE_PATH, 'r') as f:
			read_data = json.loads(f.read())
			server = read_data["config_server"]
	except Exception as exp:
		logger.error('Failed to fetch quarantine server from {}: {}'.format(REGISTRATION_CACHE_FILE_PATH, exp))
	return server

def mainIsolationController(action,isoCandidatesModules):
## Handles communication with the quarantine controller.
	# Defaults:
	gotIsolationFirewallResponse = False
	disableQuarantine = False
	controllerResponse = 'denied'
	rulesIsolationResponseFilePath = azConfigDir+'/com.amazon.isolation.response'
	rulesIsolationFilePath = azConfigDir+'/com.amazon.isolation'
	# Log:
	logger.info('Received action: %s' % action)
	logger.info('  Isolation reasons: %s' % str(isoCandidatesModules))
	# Make request from recipe:
	quarantineRequestRecipe = updateQuarantineRequestRecipe(action,isoCandidatesModules)
	# Calculate retryIntervalDeltas:
	if action != 'update':
		logger.info('Calculating backoff intervals...')
		retryIntervalDeltas = calculateExponentialBackoff()
	else:
		# Update action is a once-try:
		retryIntervalDeltas = [1]
		
	logger.info('Fetching quarantine controller server name from registration cache file...')
	quarantineControllerHost = getQuarantineControllerHost()
	
	## ACTION is ISOLATE or UPDATE:
	# Submit request to quarantine controller server:
	if action == 'isolate' or action == 'update':
		if not disableQuarantine:
			logger.info('Calling submitQuarantineRequest for isolate or update action...')
			controllerResponse = submitQuarantineRequest(quarantineControllerHost, quarantineRequestRecipe, retryIntervalDeltas )			
		else:
			logger.info('Skipping submitQuarantineRequest.')
			controllerResponse = 'denied'
				
		# Write isolation response firewall rules if isolating and not denied.
		if action == 'isolate' and controllerResponse != 'denied':
			logger.info('Got permission to isolate.  Writing isolation response firewall rules.')
			try:
				rulesIsolationResponseFile = open(rulesIsolationResponseFilePath,'w')
				rulesIsolationResponseFile.write(controllerResponse)
				rulesIsolationResponseFile.close()
				gotIsolationFirewallResponse = True
				logger.info('Wrote isolation response firewall rules.')
			except Exception as exp:
				logger.error('Failed to write isolation response firewall rules: {}'.format(exp))
			if gotIsolationFirewallResponse:				
				# Re-read main configuration - gets up-to-date parentOutputDict:
				readMainConfiguration()
				logger.info( azIdentifier + ': Setting parent state of -1.' )
				parentOutputDict['parentState'] = -1
				plistlib.writePlist(parentOutputDict,parentOutputPath)
				
		# Re-run firewall:
		if ((action == 'isolate' and controllerResponse != 'denied') or action == 'update'):
			logger.info('Running firewall module again.')
			runModule('Firewall')

	## ACTION is CONNECT: Tell the quarantine controller that the system is leaving isolation.
	elif action == 'connect':
		logger.info('Got permission to leave isolation.  Removing all isolation firewall rules.')
		# Remove all isolation firewall rules.
		ensureDeleted([rulesIsolationResponseFilePath,rulesIsolationFilePath])
		# Re-run firewall:
		logger.info('Running firewall module again.')
		runModule('Firewall')
		# Submit request to quarantine controler server for notification:
		logger.info('Calling submitQuarantineRequest for connect action...')
		controllerResponse = submitQuarantineRequest(quarantineControllerHost, quarantineRequestRecipe, retryIntervalDeltas )

	# Return:
	return gotIsolationFirewallResponse

## Supporting Functions

def updateQuarantineRequestRecipe(action, isoCandidatesModules):
## Build the HTTP POST string for submission to the controller:
	quarantineRequestRecipe = {}
	quarantineRequestRecipe['action'] = action
	quarantineRequestRecipe['reason'] = isoCandidatesModules
	return quarantineRequestRecipe
		
def submitQuarantineRequest(quarantineControllerHost,quarantineData,retryIntervalDeltas):
## Submit HTTP request to the quarantine controller.  Return the result or 'denied.'
	# Defaults:
	httpResult = 'denied'	
	server_uri = QUARANTINE_CONTROLLER_ENDPOINT.format(quarantineControllerHost)
	# Connection loop:
	for interval in retryIntervalDeltas:
		try:
			logger.info('Opening HTTPS connection to %s.' % quarantineControllerHost)
			param = {"server_uri": server_uri ,"data": quarantineData}
			response = None
			with ipc.Client(run_directory=ACME_RUN_DIRECTORY) as c:
				r_GetQuarantineResponse = ipc.Request(action="GetQuarantineResponse", options = param)
				response = c.submit_request(r_GetQuarantineResponse)

			if response.status == "Success":
				logger.info('Running action: %s.' % quarantineData['action'])
				logger.info('Get response from quarantine server: response http status code is %d.' % response.data['status_code'])
				httpStatus = response.data['status_code']
				if httpStatus == 200: # Allow response.
					logger.info('Response status was GRANTED (%s).' % str(httpStatus))
					httpResult = response.data['content']
					retryIntervalDeltas = [] # Breaks for-loop.
					logger.info("Successfully get response content from quarantine server!")
					break
				elif httpStatus == 429: # Deny response.
					logger.info('Response status was DENIED (%s).' % str(httpStatus))
					retryIntervalDeltas = [] # Breaks for-loop.
					logger.info("Request denied from quarantine server!")
					break
				else:
					# Other responses - retry until we get definitive allow/deny or retryIntervalDeltas run out.
					logger.info('Response status was (%s).' % str(httpStatus))
			else:
				logger.info('Error occured when getting response from quarantine server.')
				raise

		except Exception as exp:
			# Unreachable - retry until we get definitive allow/deny or retryIntervalDeltas run out.	
			logger.error('Could not contact {}: {}'.format(server_uri, exp))
		
		# Delay:
		logger.info('Delaying %s second(s)...' % str(interval))
		time.sleep(interval)
	# Return:
	return httpResult

def calculateExponentialBackoff():
## 1 - Given minimum wait of 1 second and maximum wait of launchd respawn interval and N desired iterations in this spawn. ##
## 2 - Construct a geometric sequennce indexed from [0,N] having N+1 elements.  Use iteration delta of +N and calculate the common ratio, r. ##
## 3 - Element at index N (the N+1-th item) has value 1*r^N=maximumWait (by definition, this is how we calculated r). ##
## 4 - Disregard element at index N (the N+1-th item); that's the next respawn by launchd. ##
## 5 - Resulting geometric sequence of N elements [0,N-1] is a series from another sequence of time deltas.##
## 6 - Calculate and return the sequence of deltas of N elements [0,N-1] ##
	minimumWait = 1
	maximumWait = mainConfigDict['exponentialBackoffVariables']['maximumWait']
	numberOfTries = mainConfigDict['exponentialBackoffVariables']['numberOfTries']
	
	r = math.pow( (maximumWait), 1/float(numberOfTries) )
	
	retryIntervals = []
	i=0
	while i < numberOfTries:
		retryIntervals.append( int( minimumWait*math.pow(r,i) ) )
		i=1+i

	retryIntervalDeltas = []
	retryIntervalDeltas.append(retryIntervals[0])
	i=1
	while i < numberOfTries:
		retryIntervalDeltas.append( retryIntervals[i] - retryIntervals[i-1] )
		i=1+i
		
	return retryIntervalDeltas

def getModuleOutputFor(toolName):
# Construct module output file path from the recipe in modulesConfigDict:
	try:
		return modulesConfigDict[toolName]['outputFile'].replace('__azModuleOutputDir__',azModuleOutputDir).replace('__azProductIdentifier__',azProductIdentifier)
	except KeyError:
		logger.error('Could not determine output file path for %s.' % toolName)
	 

def runModule(toolName):
# Runs the module specified.
	logger.info('Running module: %s...' % toolName)
	# Defaults:
	moduleExitCode = 99
	moduleCompliant = False
	moduleLastCheck = datetime.datetime.utcnow() - datetime.timedelta(hours=1)
	# Get command and output file path:
	try:
		cmd = modulesConfigDict[toolName]['command'].replace('__azModulesDir__',azModulesDir).split(' ')
	except KeyError:
		logger.error('Could not determine module file path for %s.' % toolName)
	try:
		moduleOutputFilePath = modulesConfigDict[toolName]['outputFile'].replace('__azModuleOutputDir__',azModuleOutputDir).replace('__azProductIdentifier__',azProductIdentifier)
	except KeyError:
		logger.error('Could not determine output file path for %s.' % toolName)
	# Run command, updating toolDict with output:
	if not cmd:
		logger.error('Could not run module %s - could not find its command in the modules dictionary!' % toolName)
	else:
		[output,returnCode] = azSubprocess(cmd)
		moduleExitCode = returnCode
		if not (returnCode == 0 and os.path.exists(moduleOutputFilePath)):
			logger.error('Module exited with nonzero status or its output file is missing!')
		else:
			try:
				moduleOutputDict = plistlib.readPlist(moduleOutputFilePath)
			except:
				moduleOutputDict = {}
				logger.error('Problem reading output file %s.' % moduleOutputFilePath)
			try:
				moduleCompliant = moduleOutputDict['moduleCompliant']
			except KeyError:
				logger.error('Missing moduleCompliant for %s - assuming false!' % toolName)
			try:
				moduleLastCheck = moduleOutputDict['moduleLastCheck']
			except KeyError:
				logger.error('Missing moduleLastCheck for %s - assuming one hour ago!' % toolName)
	# Override: modules that cannot isolate are always compliant.
	if not modulesConfigDict[toolName]['canIsolate']:
		moduleCompliant = True
	# Report:
	logger.info('############### Module Check Separator ###############')
	logger.info('Summary for ' + str(toolName) + '.')
	logger.info('Can cause isolation: ' + str(modulesConfigDict[toolName]['canIsolate']) + '.')
	logger.info('Exit code: ' + str(moduleExitCode) + '.')
	logger.info('Compliant: ' + str(moduleCompliant) + '.')
	logger.info('Last check: ' + str(moduleLastCheck) + '.')
	# Store keys in parent output dict:
	try:
		parentOutputDict[toolName]
	except KeyError:
		logger.info('Creating new sub dictionary for %s.' % toolName)
		parentOutputDict[toolName] = {} # Preserve module timeline data in this dict otherwise!
	parentOutputDict[toolName]['canIsolate'] = modulesConfigDict[toolName]['canIsolate']
	parentOutputDict[toolName]['moduleExitCode'] = moduleExitCode
	parentOutputDict[toolName]['moduleCompliant'] = moduleCompliant
	parentOutputDict[toolName]['moduleLastCheck'] = moduleLastCheck

def evaluateModule(toolName):
## Evaluate state for the given module and create or update its timeline.
	logger.info('Evaluating module: %s...' % toolName)
	# Defaults:
	moduleGraceVar = 1 # in-grace or compliant
	moduleIsolationVar = 1 # no isolation
	stateLabelsDict = mainConfigDict['stateLabelsDict']
	# Read module dict:
	try:
		toolDict = parentOutputDict[toolName]
	except KeyError:
		toolDict = {}
		logger.error('Parent output dict is missing dict for %s!' % toolName)

	# Compute states:
	# moduleGraceVar: one of: [0 (not in-grace), 1 (in-grace or compliant)]
	# moduleIsolationVar is one of: [-1 (isolated), 0 (isolation-candidate), 1 (no isolation)]
	# COMPLIANT: moduleState=7: moduleCompliant = 1, moduleGraceVar = 1, moduleIsolationVar = 1
	# NON-COMPLIANT, IN-GRACE: moduleState=3: moduleCompliant = 0, moduleGraceVar = 1, moduleIsolationVar = 1
	# NON-COMPLIANT, NOT-IN-GRACE: moduleState=1: moduleCompliant = 0, moduleGraceVar = 0, moduleIsolationVar = 1
	# NON-COMPLIANT, ISOLATION-CANDIDATE: moduleState=0: moduleCompliant = 0, moduleGraceVar = 0, moduleIsolationVar = 0
	if toolDict['moduleCompliant']:
		# COMPLIANT: Remove timeline data for module if present.
		#logger.info('Removing timeline for %s...' % toolName)
		try:
			del toolDict['ncDate']
		except KeyError:
			pass
		try:
			del toolDict['icDate']
		except KeyError:
			pass
			
	else:
		# NON-COMPLIANT: Compute timeline for module.
		logger.info('Timeline for %s:' % toolName)

		# Calculate timeline values.
		[calculatedNonCompliantDate, calculatedIsolationCandidateDate] = computeTimelineDatesForModule(toolName,toolDict['moduleLastCheck'])
		
		# Reconcile non compliant date:
		logger.info('-> Non-compliant Date:')
		try:
			existingNonCompliantDate = toolDict['ncDate']
			logger.info('->-> Existing: %s' % str(existingNonCompliantDate))
		except KeyError:
			existingNonCompliantDate = datetime.datetime.utcnow() + datetime.timedelta(days=365)
			logger.info('->-> Existing: No Data')
		if calculatedNonCompliantDate < existingNonCompliantDate:
			toolDict['ncDate'] = calculatedNonCompliantDate
		logger.info('->-> Calculated: %s' % str(calculatedNonCompliantDate))
		logger.info('->-> Chosen: %s' % str(toolDict['ncDate']))

		# Reconcile isolation candidate date:
		logger.info('-> Isolation candidate date:')
		try:
			existingIsolationCandidateDate = toolDict['icDate']
			logger.info('->-> Existing: %s' % str(existingIsolationCandidateDate))
		except KeyError:
			existingIsolationCandidateDate = datetime.datetime.utcnow() + datetime.timedelta(days=365)
			logger.info('->-> Existing: No Data')
		if calculatedIsolationCandidateDate < existingIsolationCandidateDate:
			toolDict['icDate'] = calculatedIsolationCandidateDate
		logger.info('->-> Calculated: %s' % str(calculatedIsolationCandidateDate))
		logger.info('->-> Chosen: %s' % str(toolDict['icDate']))
		
		# NON-COMPLIANT: Calculate time now to see where we are in the timeline.
		nowPoint = datetime.datetime.utcnow()
		if toolDict['ncDate'] < nowPoint:
			# NON-COMPLIANT: rightNow is after nonComplianceStarts; leave grace.
			moduleGraceVar = 0
			if toolDict['icDate'] < nowPoint:
				# NON-COMPLIANT, ISOLATION-CANDIDATE: rightNow is after isolationCandidateStarts.
				moduleIsolationVar = 0
				
	# Calculate module state:
	toolDict['moduleState'] = int( int(toolDict['moduleCompliant'])*math.pow(2,2) + int(moduleGraceVar)*math.pow(2,1) + int(moduleIsolationVar) )
	# Report:
	logger.info('State for %s: ' % toolName)
	logger.info('-> State Number: %s' % str(toolDict['moduleState']) )
	logger.info('-> State Label: %s' % str(stateLabelsDict[str(toolDict['moduleState'])]) )
	# Store edited toolDict in parent output dict:
	parentOutputDict[toolName] = toolDict

def computeTimelineDatesForModule(toolName,moduleLastCheck):
## Computes non-compliance and isolation-candidate dates for a given module.
	logger.info('Computing timeline for %s...' % toolName)
	# Read necessary timeline configuration data:
	try:
		nonCompliantPointDict = modulesConfigDict[toolName]['nonCompliantPoint']
		nonCompliantMinGrace = nonCompliantPointDict['min-grace']
		nonCompliantMaxGrace = nonCompliantPointDict['max-grace']
		nonCompliantAbsoluteDate = nonCompliantPointDict['date-due']

		isolationCandidatePointDict = modulesConfigDict[toolName]['isolationCandidatePoint']
		isoCandidateIntervalFromNonCompliantPoint = isolationCandidatePointDict['grace-from-nonCompliantPoint']
	except KeyError:
		logger.error('Missing timeline data in modules configuration for %s!' % toolName)

	# Calculate nonComplianceStarts in this fashion:
	# This ensures that the nonComplianceStarts is in the future.

	# 0 - Define earliestPossibleDate: moduleLastCheck + nonCompliantMinGrace
	# 0 - Define relDate: moduleLastCheck + nonCompliantMaxGrace
	earliestPossibleDate = moduleLastCheck + datetime.timedelta(seconds=nonCompliantMinGrace)
	# 1 - Compare relative date to absolute date and choose the EARLIER of the two.	
	nonComplianceStarts = moduleLastCheck + datetime.timedelta(seconds=nonCompliantMaxGrace)
	if nonCompliantAbsoluteDate < nonComplianceStarts:
		nonComplianceStarts = nonCompliantAbsoluteDate
	# 2 - Compare the result of [1] to the earliestPossibleDate.  Choose the LATER of the two.
	if nonComplianceStarts < earliestPossibleDate:
		nonComplianceStarts = earliestPossibleDate

	# 3 - Calculate isolation-candidate date from nonComplianceStarts:
	isolationCandidateStarts = nonComplianceStarts + datetime.timedelta(seconds=isoCandidateIntervalFromNonCompliantPoint)

# Return:
	return nonComplianceStarts, isolationCandidateStarts

def writeStatesToTaniumFile():
## Writes the module state labels to the Tanium semaphore file.
	# Config:
	taniumStr = mainConfigDict['taniumRecipeStr']
	taniumSemaphorePath = mainConfigDict['taniumSemaphorePath']
	stateLabelsDict = mainConfigDict['stateLabelsDict']
	# Assemble string:
	for toolName in enabledModules:
		try:
			moduleStateLabel = str(parentOutputDict[toolName]['moduleState'])
			moduleStateTaniumLabel = stateLabelsDict['taniumMappings'][moduleStateLabel]
		except KeyError:
			moduleStateTaniumLabel = 'ERROR'
			logger.error('Error looking up module state label for %s!' % toolName)
		taniumStr = taniumStr.replace('__'+toolName+'__',moduleStateTaniumLabel)
	# Write string to file:	
	try:
		file = open(taniumSemaphorePath,'w')
		file.write(taniumStr)
		file.close()
	except:
		logger.error('Error writing to %s!' % taniumSemaphorePath)

def writeInfoSecSemaphores():
## Writes the various InfoSec semaphore files.
	# Config:
	infoSecSemaphorePathRecipe = mainConfigDict['infoSecSemaphorePathRecipe']
	infoSecSemaphoresDir = mainConfigDict['infoSecSemaphoresDir']
	stateLabelsDict = mainConfigDict['stateLabelsDict']
	# Start with an empty directory path for the semaphores (whose names vary):
	if os.path.exists(infoSecSemaphoresDir):
		try:
			shutil.rmtree(infoSecSemaphoresDir)
		except:
			logger.error('Error deleting path at %s!' % infoSecSemaphoresDir)
	try:
		os.makedirs(infoSecSemaphoresDir,0700)
	except:
		logger.error('Error creating new path at %s!' % infoSecSemaphoresDir)

	# MODULE SEMAPHORES
	# Loop though modules:
	for toolName in enabledModules:
		try:
			moduleStateLabel = str(parentOutputDict[toolName]['moduleState'])
			moduleStateInfoSecLabel = stateLabelsDict['infoSecMappings'][moduleStateLabel]
		except KeyError:
			moduleStateInfoSecLabel = 'error'
			logger.error('Error looking up module state label for %s!' % toolName)
		# Determine path for semaphore:
		moduleSemaphorePath = infoSecSemaphorePathRecipe.replace('__module__',toolName).replace('__moduleState__',moduleStateInfoSecLabel)
		# Write semaphore:
		try:
			file = open(moduleSemaphorePath,'w')
			file.write(' ')
			file.close()
		except:
			logger.error('Error writing %s!' % moduleSemaphorePath)
	
	# PARENT SEMAPHORES
	parentState = parentOutputDict['parentState']
	if parentState == -1:
		isQuarantinedLabel = 'yes'
	elif parentState <= 7:
		isQuarantinedLabel = 'no'
	else:
		isQuarantinedLabel = 'error'

	if (parentState == 3) or (parentState == 7):
		isCompliantLabel = 'yes'
	elif parentState < 3:
		isCompliantLabel = 'no'
	else:
		isCompliantLabel = 'error'
	
	# Determine path for the "is quarantined" semaphore:
	isQuarantinedSemaphorePath = infoSecSemaphorePathRecipe.replace('__module__','quarantined').replace('__moduleState__',isQuarantinedLabel)
	# Write semaphore:
	try:
		file = open(isQuarantinedSemaphorePath,'w')
		file.write(' ')
		file.close()
	except:
		logger.error('Error writing %s!' % isQuarantinedSemaphorePath)

		# Determine path for the "is compliant" semaphore:
	isCompliantSemaphorePath = infoSecSemaphorePathRecipe.replace('__module__','compliant').replace('__moduleState__',isCompliantLabel)
	# Write semaphore:
	try:
		file = open(isCompliantSemaphorePath,'w')
		file.write(' ')
		file.close()
	except:
		logger.error('Error writing %s!' % isCompliantSemaphorePath)

def showModuleStatus():
## Print the list of enabled and disabled modules (including disabledReason).
	readMainConfiguration()
	if enabledModules == []:
		logger.info('No modules are enabled.')
	else:
		logger.info('Enabled Modules:')
		for module in enabledModules:
			logger.info('  %s' % module)

	if disabledModules == []:
		logger.info('No modules are disabled.')
	else:
		logger.info('Disabled Modules:')
		for module in disabledModules:
			logger.info('  %s' % module)
			try:
				disabledReason = modulesConfigDict[module]['disabledReason']
				logger.info('  reason: %s' % disabledReason)
			except KeyError:
				pass

def azBuildModulesArray(modulesConfigDict,desiredBoolean):
# Build returnedModules:
	returnedModules = []
	for module in modulesConfigDict['modules']:
		module_isEnabled = modulesConfigDict[module]['isEnabled']
		if module_isEnabled == desiredBoolean:
			returnedModules.append(module)
	return returnedModules

def azShowToolHelp():
	print '''
-------
Mac Quarantine: quarantine
Version 1.5.0.5 Copyright Amazon
Evaluates the computer's state and isolates if required.
-------
USAGE: quarantine verb
evaluate : Run and evaluate all modules, updating parent compliance state.
moduleStatus : Print the list of enabled and disabled modules (including reasons for those disabled).
-------
'''

def main():
## MAIN
	if not argsValid():
		azShowToolHelp()
	else:
		logger.info('############### Begining Quarantine Evaluation ###############')
		logger.info('Executing with ' + str(sys.argv[1]) + ' arguments')
		logger.info('Reading Main Configuration')
		# Read main configuration:
		readMainConfiguration()
		# Get computer name - used by QuarantineAgent to show the computer's name:
		logger.info('Getting Computer name')
		parentOutputDict['computerName'] = getLocalHostNameFromDynamicStore()

		# Run modules:
		for toolName in enabledModules :
			runModule(toolName)
	
		# Evaluate all modules and compute new parent state:
		logger.info('Evaluating Modules')
		[newParentState, isoCandidatesModules] = evaluateModulesAndComputeParentState()
		
		# Compare new parent state to previous; determine isolation actions:
		logger.info('Determining Action')
		action = determineIsolationAction(newParentState, isoCandidatesModules)
		
		# Update the Tanium File (legacy):
		logger.info('Writing Tanium Semaphore')
		writeStatesToTaniumFile()

		# Write various InfoSec semaphores:
		logger.info('Writing Infosec semaphore')
		writeInfoSecSemaphores()
		
		# Write parentOutputDict.
		logger.info('Writing Ouptut to temp file')
		plistlib.writePlist(parentOutputDict,parentOutputPath)
	
		# Isolation:
		if action != '':
			logger.info('Getting isolation firewall response from quarantine controller')
			gotIsolationFirewallResponse = mainIsolationController(action,isoCandidatesModules)
			# Re-run semaphore actions and re-write parent output dictionary.
			# Isolation may take some time, so we do this again after isolating.
			writeStatesToTaniumFile()
			writeInfoSecSemaphores()
			logger.info('Writing output file...' )
			plistlib.writePlist(parentOutputDict,parentOutputPath)

if __name__ == '__main__':
	global azIdentifier
	global logger
	azIdentifier = 'com.amazon.acme.quarantine'
	logger = azLogger(azIdentifier)
	#main()
	try:
		main()
	except Exception as exp:
		logger.error('{}: Generic exception.: {}'.format(azIdentifier, exp))
