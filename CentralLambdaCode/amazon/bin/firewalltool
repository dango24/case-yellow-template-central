#!/System/Library/Frameworks/Python.framework/Versions/Current/bin/python

## Mac Quarantine: firewalltool
## Copyright Amazon
## Written by Gerrit DeWitt (gerritd@amazon.com)
## Updated by Jason Simmons (jasosimm@amazon.com)
## Update by LJ Cline (joscline@amazon.com)
## Version 1.5.0.6 - 2018-10-08
## Project started 2013-04-22

import os, sys, ssl, OpenSSL, time, datetime
sys.path.insert(0,'/usr/local/amazon/libexec/quarantine')
from common_quarantine import *

def getActiveInterfacesList(dynamicStore,interfaces):
## Prunes interface list, returning only enabled ones with active links:
	activeInterfaces = []
	for interface in interfaces:
		state = SCDynamicStoreCopyValue(dynamicStore,'State:/Network/Interface/'+interface+'/Link')
		if (state != None) and state['Active']:
			# A state of None means disabled.
			# When state exists: interface is active or inactive.
			activeInterfaces.append(interface)
	return activeInterfaces

def getPrimaryInternalInterface(domainController):
## Attempts to find the BSD interface name holding the default route to the given domain controller.
## Returns the BSD interface name or blank (if an interface cannot be found).
## The returned BSD interface name may be considered the primary internal interface.
	# Default:
	primaryInternalInterface = 'invalid'
	if domainController != 'invalid':
		# Run route get:
		cmd = ['/sbin/route','get',domainController]
		[output,returnCode] = azSubprocess(cmd)
		# Print errors:
		if returnCode != 0:
			logger.error('route exited with code %s!' % str(returnCode))
		# Parse output:
		for outputItem in output.split('\n'):
			if outputItem.find('interface:') != -1:
				primaryInternalInterface = outputItem.replace('interface:','').replace(' ','')
				break
	# Return:
	return primaryInternalInterface

def verifyDomainControllerAgainstCA(domainController, caCN):
## Improvement for future release: migrate to openssl python commands and use CAs installed
## by ACME Assistants and Automations (/usr/local/amazon/var/acme/ca).
## Download certificate from the closest domain controller to dcCertPath.
## Get CA cert (CN=caCN) from keychain at systemKeychainPath, and store to caCertPath.
## Verify domain controller certificate against CA.  Return true/false.
	# Defaults:
	verifiedCert = False
	dcCertContents = ''
	caCertContents = ''
	dcCertPath = azMainConfigurationDict['dcCertPath']
	caCertPath = azMainConfigurationDict['caCertPath']

	# Query current domain controller for its certificate.
	dcCertContents = ssl.get_server_certificate( (domainController,636) )
	file = open(dcCertPath,'w')
	file.write(dcCertContents)
	file.close()

	# Find the CA certificate.
	cmd = ['/usr/bin/security','find-certificate','-c',caCN,'-p','/Library/Keychains/System.keychain']
	[output,returnCode] = azSubprocess(cmd)
	if (output != '') and (returnCode == 0):
		file = open(caCertPath,'w')
		file.write(output)
		file.close()

	# Verify domain controller certificate:
	if os.path.exists(dcCertPath) and os.path.exists(caCertPath):
		cmd = ['/usr/bin/security','verify-cert','-c',dcCertPath,'-r',caCertPath]
		[output,returnCode] = azSubprocess(cmd)
		# Only return true if output matches expected and zero return code.  	
		if (output.find('certificate verification successful') != -1) and (returnCode == 0):
			verifiedCert = True

	# Clean up:
	ensureDeleted([dcCertPath,caCertPath])

	# Return result:
	logger.info('Certificate Verified: ' + str(verifiedCert) + '.')
	return verifiedCert
	
def makeInternalInterfaceList(enabledActiveInterfaces,primaryInternalInterface):
## Determines the list of internal interfaces.
	internalInterfaces = []
	dhcpServers = azMainConfigurationDict['dhcpServers']

	if primaryInternalInterface != 'invalid' and enabledActiveInterfaces and dhcpServers:
		# Loop through the enabled active interfaces:
		for interface in enabledActiveInterfaces:
			# Run ipconfig:
			cmd = ['/usr/sbin/ipconfig','getpacket',interface]
			[output,returnCode] = azSubprocess(cmd)
			# Print errors:
			if returnCode != 0:
				logger.error('ipconfig exited with code %s!' % str(returnCode))
			# Look for a DHCP server in output:
			for server in dhcpServers:
				if output.find(server) != -1:
					internalInterfaces.append(interface)
					break
	# Return:
	return internalInterfaces

def validateDomainController(adDomain, trustedCAList):
# Look up the domain controller and determine if is to be trusted.
	# Defaults:
	dcTrusted = False
	dcCA = 'invalid'

	# Find domain controller.
	domainController = findDomainController(adDomain)
	if domainController != 'invalid':
		# Attempt verification of DC cert against each CA:
		for theCA in trustedCAList:
			logger.info('Checking domain controller certificate against CA: %s' % str(theCA))
			dcTrusted = verifyDomainControllerAgainstCA(domainController, theCA)
			if dcTrusted:
				dcCA = theCA
				break
	# Return:
	return domainController,dcTrusted,dcCA

def parseIsolationRuleStr(rules):
## Given rule string from the quarantine controller, generate pf syntax string.
	rules = rules.split('\n')
	parsedRules = '# Isolated network firewall configuration for Quarantine.\n## This file is just configuration information.\n\n'
	for rule in rules:
		try:
			[theProto,subNet,portRange,direction] = rule.split(',')
			portRange = portRange.replace('-',':')
			if subNet == '*':
				subNet = 'any'
			if direction == 'in':
				parsedRule = azMainConfigurationDict['firewallRecipes']['incoming']
			else:
				parsedRule = azMainConfigurationDict['firewallRecipes']['outgoing']
		
			parsedRules = parsedRules + parsedRule.replace('__proto__',theProto).replace('__net__',subNet).replace('__port__',portRange) + '\n'
		except:
			# Treat as comment if error parsing:
			parsedRules = parsedRules + '#' + rule + '\n'
	return parsedRules

def parseMainRules(enabledActiveInterfaces,primaryInternalInterface,internalInterfaces):
## Given list of "all" (active) interfaces and internal interfaces (if any):
	azConfigDir = azMainConfigurationDict['azConfigDir']
	rulesIsolationPrimaryFilePath = azConfigDir+'/com.amazon.isolation.primary'
	rulesDefaultTemplateFilePath = azConfigDir+'/template-com.amazon.default'
	rulesMultihomeTemplateFilePath = azConfigDir+'/template-com.amazon.multihome'
	rulesInternalTemplateFilePath = azConfigDir+'/template-com.amazon.internal'
	rulesCustomTemplateFilePath = azConfigDir+'/template-com.amazon.custom'
	if os.path.exists(rulesIsolationPrimaryFilePath) and os.path.exists(rulesDefaultTemplateFilePath) and os.path.exists(rulesMultihomeTemplateFilePath) and os.path.exists(rulesInternalTemplateFilePath):
		logger.info('Detected all firewall rules templates.')
	else:
		logger.info('Detected missing firewall rules templates.')
		reinstallACME()

	# Main firewall rules default to empty:
	rulesMain = ''
	
# STEP 1: Generate/update/parse rules:
	if isolationMode:
		# Relevant file paths - isolated:
		rulesIsolationResponseFilePath = azConfigDir+'/com.amazon.isolation.response'
		rulesIsolationFilePath = azConfigDir+'/com.amazon.isolation'
		# Isolation Mode Case I - Optional.  We should be here if an isolation response from quarantine exists.
		if os.path.exists(rulesIsolationResponseFilePath):
			logger.info('Detected un-parsed isolation firewall rules file.  Parsing...' )
			# Read isolation rules received from server via quarantine.
			file = open(rulesIsolationResponseFilePath,'r')
			unparsedRules = file.read()
			file.close()
			# Parse isolation rules.
			parsedRules = parseIsolationRuleStr(unparsedRules)
			# Write parsed isolation rules.
			try:
				file = open(rulesIsolationFilePath,'w')
				file.write(parsedRules)
				file.close()
				logger.info('Wrote parsed isolation rules.')
			except:
				logger.info('Failed to write parsed isolation rules.')
			# Remove unparsed isolation rules.
			ensureDeleted([rulesIsolationResponseFilePath])
		
		# Isolation Mode Case II - Necessary for isolation
		# Parsed isolation rules exist; apply them (isolation mode).
		if not os.path.exists(rulesIsolationFilePath):
			logger.info('Isolation requested, but missing rules.  Will not alter firewall config.')
		else:
			logger.info('Detected parsed isolation firewall rules.')
			rulesMain = rulesMain + '\nanchor "com.amazon.isolation.primary"\nload anchor "com.amazon.isolation.primary" from "' + rulesIsolationPrimaryFilePath + '"\n'
			rulesMain = rulesMain + '\nanchor "com.amazon.isolation"\nload anchor "com.amazon.isolation" from "' + rulesIsolationFilePath + '"\n'

	else:
# Normal Rules
		# Convert arrays to formatted strings for pf:
		enabledActiveInterfaces = '{%s}' % ','.join(enabledActiveInterfaces)
		internalInterfaces = '{%s}' % ','.join(internalInterfaces)
		# Relevant file paths - normal mode:
		rulesDefaultFilePath = azConfigDir+'/com.amazon.default'
		rulesMultihomeFilePath = azConfigDir+'/com.amazon.multihome'
		rulesInternalFilePath = azConfigDir+'/com.amazon.internal'
		rulesCustomFilePath = azConfigDir+'/com.amazon.custom'
		rulesCiscoAnyconnectPath = '/opt/cisco/anyconnect/ac_pf.conf'
		if enabledActiveInterfaces != '{}':
			# If no Amazon connected interfaces, apply default anchor
			if internalInterfaces == '{}':
				logger.info('Writing default packet filter rules for' + str(enabledActiveInterfaces) + '.')
				with open(rulesDefaultTemplateFilePath, 'r') as fr:
					rulesDefaultTemplate = fr.read()
				rules = rulesDefaultTemplate.replace('__allInterfaces__',enabledActiveInterfaces)
				with open(rulesDefaultFilePath, 'w') as fw:
					fw.write(rules)
				
				rulesMain = rulesMain + '\nanchor "com.amazon.default"\nload anchor "com.amazon.default" from "' + rulesDefaultFilePath + '"\n'
			# Else Amazon connected interface, apply multihome anchor
			else:
				logger.info('Writing multihome packet filter rules for ' + str(enabledActiveInterfaces) + '.')
				with open(rulesMultihomeTemplateFilePath, 'r') as fr:
					rulesMultihomeTemplate = fr.read()
				rules = rulesMultihomeTemplate.replace('__allInterfaces__',enabledActiveInterfaces).replace('__internalInterfaces__',internalInterfaces)
				with open(rulesMultihomeFilePath, 'w') as fw:
					fw.write(rules)
				
				rulesMain = rulesMain + '\nanchor "com.amazon.multihome"\nload anchor "com.amazon.multihome" from "' + rulesMultihomeFilePath + '"\n'

			if internalInterfaces != '{}':
				logger.info('Writing new internal packet filter rules for ' +  str(internalInterfaces) + '.')
				with open(rulesInternalTemplateFilePath, 'r') as fr:
					rulesInternalTemplate = fr.read()
				rules = rulesInternalTemplate.replace('__internalInterfaces__',internalInterfaces)
				with open(rulesInternalFilePath, 'w') as fw:
					fw.write(rules)
				
				rulesMain = rulesMain + '\nanchor "com.amazon.internal"\nload anchor "com.amazon.internal" from "' + rulesInternalFilePath + '"\n'
			#write custom rules
			if os.path.exists(rulesCustomTemplateFilePath):
				logger.info('Writing custom packet filter rules.' )
				with open(rulesCustomTemplateFilePath, 'r') as fr:
					rulesCustomTemplate = fr.read()
				#not writing any explicit interfaces yet for custom rules
				rules = rulesCustomTemplate
				with open(rulesCustomFilePath, 'w') as fw:
					fw.write(rules)
						
				rulesMain = rulesMain + '\nanchor "com.amazon.custom"\nload anchor "com.amazon.custom" from "' + rulesCustomFilePath + '"\n'
			if "utun" in primaryInternalInterface and os.path.exists(rulesCiscoAnyconnectPath):
				logger.info('Writing cisco anyconnect packet filter rules.' )
				rulesMain = rulesMain + '\nanchor "cisco.anyconnect.vpn" \nload anchor "cisco.anyconnect.vpn" from "' + rulesCiscoAnyconnectPath + '"\n'
	# Return:
	return rulesMain

def applyRules(rulesMain):		
## Update pf rules and reload pf.
	# Defaults:
	didWriteMainRules = False
	didReloadPacketFilter = False
	moduleCompliant = False
	azConfigDir = azMainConfigurationDict['azConfigDir']
	mainRulesFilePath = azConfigDir+'/com.amazon.main'

	# New rules.
	if rulesMain != '':
		# Write main rules:
		try:
			file = open(mainRulesFilePath,'w')
			file.write(rulesMain)
			file.close()
			didWriteMainRules = True
			logger.info('Wrote new main packet filter rules.')
		except:
			logger.info('Failed to write main firewall rules.')
		# Load rules:
		didReloadPacketFilter = loadPacketFilterWithRuleset(mainRulesFilePath)
		if didReloadPacketFilter:
			logger.info('Refreshed packet filter rules.')
		else:
			logger.info('Failed to refresh packet filter rules.')
		# Update result:
		if didWriteMainRules and didReloadPacketFilter:	
			moduleCompliant = True

	elif (not isolationMode) and (enabledActiveInterfaces == '{}'):
		# No rules to apply because rulesMain is blank.  This happens when:
		# There's an error applying isolation mode rules.
		# In normal mode there were no enabledActiveInterfaces - OS X said no network connection.
		moduleCompliant = True

	# Return:
	return moduleCompliant

def loadPacketFilterWithRuleset(configPath):
## Loads pf with a given main rule set file.
	didSetRules = False
	cmd = ['/sbin/pfctl','-d']
	[output,returnCode] = azSubprocess(cmd)
	cmd = ['/sbin/pfctl','-e','-f',configPath]
	[output,returnCode] = azSubprocess(cmd)
	if returnCode == 0:
		didSetRules = True
	return didSetRules		

def main():
	## MAIN
	logger.info('####### Begining Firewalltool Evaluation #######')
	logger.info(azIdentifier)
	outputPath = outputPathForModuleNamed('Firewall')

	# Date stamp:
	lastRun = datetime.datetime.utcnow()
	# Read configuration:

	trustedCAList = azMainConfigurationDict['trustedCertificateAuthorities']
	vpnInterface = azMainConfigurationDict['vpnInterface']
	
	# Determine if isolated by quarantine:
	global isolationMode
	isolationMode = False
	try:
		quarantineDict = readQuarantineOutputDict()
	except:
		quarantineDict = {}
		logger.error('Could not read quarantine output dictionary!')
	try:
		parentState = quarantineDict['parentState']
		if parentState == -1:
			isolationMode = True
	except KeyError:
		logger.error('Could not determine quarantine parent state from dictionary!')
	logger.info('Isolated by Quarantine: %s' % str(isolationMode))
	
	# Enumerate interfaces:
	allInterfaces = azGetInterfacesList()
	logger.info('Interfaces from Dynamic Store: %s' % ', '.join(allInterfaces))
	# Determine enabled, active interfaces:
	enabledActiveInterfaces = getActiveInterfacesList(azInitDynamicStore(),allInterfaces)
	if enabledActiveInterfaces == []:
		logger.info('Active and enabled interfaces: None')
	else:
		logger.info('Active and enabled interfaces: %s' % ', '.join(enabledActiveInterfaces))

	# Validate domain controller:
	[domainController,dcTrusted,dcCA] = validateDomainController(adDomain, trustedCAList)
	if domainController == 'invalid':
		logger.error('No Amazon domain controller found!')
	else:
		logger.info('Domain controller: ' + str(domainController) + '.')
	logger.info('DC Certificate Valid: ' + str(dcTrusted) + '.')
	logger.info('CA For Validation: ' + str(dcCA) + '.')

	# Determine the primary internal interface:
	primaryInternalInterface = getPrimaryInternalInterface(domainController)
	logger.info('Primary internal interface: ' + str(primaryInternalInterface) + '.')
	# Determine all internal interfaces:
	#instead of choosing adapter names from a list, any default route to a dc with a utun adapter is determined to be the primary
	if "utun" in primaryInternalInterface:
		internalInterfaces = [primaryInternalInterface]
		logger.info('Updating tunnel adapter MTU.' )
		cmd = ['/sbin/ifconfig', primaryInternalInterface, 'mtu', '1406']
		[output,returnCode] = azSubprocess(cmd)
		if returnCode == 0:
			logger.info('Set ' + str(primaryInternalInterface) + ' mtu to 1406')
		else:
			logger.error('Failed to set MTU for' + str(primaryInternalInterface))
	else:			
		internalInterfaces = makeInternalInterfaceList(enabledActiveInterfaces,primaryInternalInterface)
		if internalInterfaces == []:
			logger.info('Internal interfaces: None')
		else:
			logger.info('Internal interfaces: %s' % ', '.join(internalInterfaces) + '.')

	# Set firewall rules:
	rulesMain = parseMainRules(enabledActiveInterfaces,primaryInternalInterface,internalInterfaces)
	moduleCompliant = applyRules(rulesMain)
	# Read output file:
	try:
		outputDict = plistlib.readPlist(outputPath)
	except:
		outputDict = {}

	# Set keys:
	outputDict['moduleLastCheck'] = lastRun
	outputDict['moduleCompliant'] = moduleCompliant
	outputDict['networkInterfaces'] = {}
	outputDict['networkInterfaces']['all'] = allInterfaces
	outputDict['networkInterfaces']['enabledActive'] = enabledActiveInterfaces
	outputDict['networkInterfaces']['internalList'] = internalInterfaces
	outputDict['networkInterfaces']['internalPrimary'] = primaryInternalInterface
	outputDict['domainController'] = {}
	outputDict['domainController']['hostname'] = domainController
	outputDict['domainController']['isTrusted'] = dcTrusted
	outputDict['domainController']['signedBy'] = dcCA





	# Write outputDict:
	if outputDict != {}:
		plistlib.writePlist(outputDict,outputPath)

if __name__ == '__main__':
	global azIdentifier
	global logger
	azIdentifier = 'com.amazon.acme.quarantine.firewalltool'
	logger = azLogger(azIdentifier)
	try:
		main()
	except:
		logger.error('Generic exception.')
