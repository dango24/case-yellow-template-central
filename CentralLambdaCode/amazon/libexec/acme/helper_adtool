#!/System/Library/Frameworks/Python.framework/Versions/Current/bin/python

## helper_adtool
## Written by Gerrit DeWitt (gerritd@amazon.com)
## Modified by Jason Simmons (jasosimm@amazon.com)
## Version 2.9.8.5 - 2018-10-25 Copyright Amazon
## Script for binding to Active Directory, given certain environment variables.
## Based on earlier scripts by Beau Hunter (beauhunt@amazon.com) and Jeremy Kelley (jekelley@amazon.com).

from __future__ import unicode_literals
import os, sys, time, datetime, uuid
import pexpect
from common_acme import *

## SUBROUTINES

def getADStatus():
## Determine the status of AD connectivity: not-bound, maybe-bound, bound.
	# Defaults:
	haveValidDomainController = False
	resolvedTestUser = False 
	status = "not-bound"
	# Try to get a domain controller address via DNS-SRV records to determine if the computer is on the corporate network.
	# Do this check in all cases.  It is used to by the Assistant UI to decide whether the user should be asked to bind.
	logger.debug('getADStatus: Searching for the PDC...')
	domainController = findDomainController(adDomain)
	if domainController.find(adDomain) == -1:
		ipcSendAndPrintMessage('getADStatus: Could not find DNS-SRV records for the PDC - expected when off-network.',fromHelperSocketPath, azIdentifier)
	else:
		haveValidDomainController = True
		ipcSendAndPrintMessage('getADStatus: PDC is: ' + domainController,fromHelperSocketPath, azIdentifier)
	# Determine if the AD plugin thinks it's bound:
	[computerAccountValid, computerAccount] = validateComputerAccount(adDomainSearchPath)
	if not computerAccountValid:
		ipcSendAndPrintMessage('getADStatus: OS X indicates not bound to Active Directory.',fromHelperSocketPath, azIdentifier)
	else:
		ipcSendAndPrintMessage('getADStatus: OS X indicates bound to Active Directory.',fromHelperSocketPath, azIdentifier)
		status = "maybe-bound"
		if haveValidDomainController:			
			# Attempt to resolve the test user account:
			resolvedTestUser = validateTestUser(adTestUserName,adTestUserId)
			if not resolvedTestUser:
				status = "maybe-not-bound"
				ipcSendAndPrintMessage('getADStatus: Could not resolve the AD test user account.  This may mean a rebind is required, but can also be a transient error. Retry again shortly.',fromHelperSocketPath, azIdentifier)
			else:
				status = "bound"
				ipcSendAndPrintMessage('getADStatus: Communication operational - resolved the AD test user account.',fromHelperSocketPath, azIdentifier)
	# Return:
	return status, [domainController, computerAccount, resolvedTestUser]

def getADPrefsStatus():
## Gets Active Directory plugin prefs status.
	# Default:
	prefsArray = []
	pluginPrefsVerified = False
	haveFalseInPrefsArray = False
	# Get dsconfigad output in xml:
	cmd = ['/usr/sbin/dsconfigad','-show','-xml']
	[output,returnCode] = azSubprocess(cmd)
	if ( returnCode == 0 ) and output:
		dsConfigOutputDict = azReadPlistFromStr(output)
		# These should be True or not(False):
		prefsArray.append( dsConfigOutputDict['Administrative']['Authentication from any domain'] )
		prefsArray.append( dsConfigOutputDict['User Experience']['Create mobile account at login'] )
		prefsArray.append( dsConfigOutputDict['User Experience']['Force home to startup disk'] )
		prefsArray.append( not(dsConfigOutputDict['User Experience']['Require confirmation']) )
		prefsArray.append( not(dsConfigOutputDict['User Experience']['Use Windows UNC path for home']) )
		# Check password change interval:
		if ( dsConfigOutputDict['Administrative']['Password change interval'] == 0 ):
			prefsArray.append(True)
		else:
			prefsArray.append(False)
		# Check shell:
		if ( dsConfigOutputDict['User Experience']['Shell'] == '/bin/bash' ):
			prefsArray.append(True)
		else:
			prefsArray.append(False)			
		# Check groups - Allowed admin groups key may be missing; use try-catch:
		try:
			measuredAdminGroups = ','.join(dsConfigOutputDict['Administrative']['Allowed admin groups']).replace('"','')
			if ( measuredAdminGroups == adPluginOptionsDict['groups'] ):
				prefsArray.append(True)
		except:
			prefsArray.append(False)
	# Determine pluginPrefsVerified:
	for pref in prefsArray:
		if not (pref and True):
			haveFalseInPrefsArray = True
			break
	# The pluginPrefsVerified is true only when we have a non-empty prefsArray with all True elements:
	if (not haveFalseInPrefsArray) and (prefsArray != []):
		pluginPrefsVerified = True
	# Return:
	return pluginPrefsVerified

def setDirectoryPluginPrefs():
## Sets Active Directory plugin prefs for cached accounts, admin groups, etc.
	# Default:
	pluginPrefsSet = False
	cmdsArray = []
	cumulativeReturnCodes = 0
	# Build cmdsArray:
	cmdsArray.append([ '/usr/sbin/dsconfigad','-mobile',adPluginOptionsDict['enableMobileHome'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-mobileconfirm',adPluginOptionsDict['confirmMobileHome'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-localhome',adPluginOptionsDict['localHome'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-useuncpath',adPluginOptionsDict['useUncPath'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-shell',adPluginOptionsDict['shell'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-groups',adPluginOptionsDict['groups'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-alldomains',adPluginOptionsDict['allDomains'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-passinterval',adPluginOptionsDict['passInterval'] ])
	cmdsArray.append([ '/usr/sbin/dsconfigad','-nouid','-nogid','-noggid','-nopreferred' ])
	# Run items in cmdsArray:
	for cmd in cmdsArray:
		[output,returnCode] = azSubprocess(cmd)
		cumulativeReturnCodes = cumulativeReturnCodes + returnCode
	# Determine pluginPrefsSet:
	if cumulativeReturnCodes == 0:
		pluginPrefsSet = True
	# Return:
	return pluginPrefsSet

def bindToDomain(computerName, adBindUser, adBindPassword):
## Adds the computer to Active Directory.
	# Default:
	dsconfigFinished = False
	# Update system clock:
	ntpUpdate(ntpServer)
	# Raise logging verbosity:
	odSetLogging('debug')
	try:
		# Run dsconfigad:
		cmd = '/usr/sbin/dsconfigad -add ' + adDomain + ' -computer ' + computerName + ' -ou ' + adOU + ' -force -username ' + adBindUser
		child = pexpect.spawn(cmd, timeout=180)
		child.expect('.*assword:')
		child.sendline(adBindPassword)
		# Block on dsconfigad execution:
		child.read(size=-1)
		dsconfigFinished = True
	except:
		ipcSendAndPrintMessage('dsconfigad timed out.',fromHelperSocketPath, azIdentifier)
	finally:
		# Lower logging verbosity:
		odSetLogging('default')
		# Pause:
		time.sleep(5)
		# Return:
		return dsconfigFinished

def unbindFromDomain(adBindUser, adBindPassword):
## Removes the computer from Active Directory.
	# Default:
	dsconfigFinished = False
	# Raise logging verbosity:
	odSetLogging('debug')
	try:
		# Run dsconfigad:
		cmd = '/usr/sbin/dsconfigad -remove -force -username ' + adBindUser
		child = pexpect.spawn(cmd, timeout=120)
		child.expect('.*assword:')
		child.sendline(adBindPassword)
		# Block on dsconfigad execution:
		child.read(size=-1)
		dsconfigFinished = True
	except:
		ipcSendAndPrintMessage('dsconfigad timed out.',fromHelperSocketPath, azIdentifier)
	finally:
		# Lower logging verbosity:
		odSetLogging('default')
		# Pause:
		time.sleep(5)
		# Return:
		return dsconfigFinished

def configureKerberosClient(kerberosConfigFilePath, kerberosLegacyConfigFilePath, kerberosConfigFileContentArray, sshConfigFilePath):
## Sets various Kerberos configuration for services.
	# Make sure that edu.mit.Kerberos is gone:
	ensureDeleted([kerberosLegacyConfigFilePath])
	# Move existing /etc/krb5.conf aside:
	ensureMoved([kerberosConfigFilePath])
	# Remove any Kerberos config in the local directory node:
	cmd = ['/usr/bin/dscl','/Local/Default','delete','/Config/Kerberos:' + adDomain]
	[output,returnCode] = azSubprocess(cmd)
	# Write our contents to /etc/krb5.conf:
	try:
		kerberosConfigFileContents = '\n'.join(kerberosConfigFileContentArray)
		kerberosConfigFileObj = open(kerberosConfigFilePath,'w')
		kerberosConfigFileObj.write(kerberosConfigFileContents)
		kerberosConfigFileObj.close()
		logger.info('configureKerberosClient: Wrote Kerberos config file.' )
	except:
		logger.info('configureKerberosClient: ERROR: Failed to write Kerberos config file.' )
	# Modify the ssh_config file:
	try:
		# OS X 10.11 moved ssh_config
		mainDictionary = azLoadMainDictionary()
		sshConfigFilePathNew = mainDictionary['sshConfigFilePathNew']
		if os.path.exists(sshConfigFilePathNew):
			sshConfigFilePath = sshConfigFilePathNew
		# Read:
		sshConfigFileObj = open(sshConfigFilePath,'r')
		sshConfigFileContents = sshConfigFileObj.read()
		sshConfigFileObj.close()
		sshConfigFileContentArray = sshConfigFileContents.split('\n')
		newContentArray = []
		# Parse and modify sshConfigFileContents:
		for line in sshConfigFileContentArray:
			if (line.find('GSSAPIAuthentication') != -1):
				newContentArray.append('    GSSAPIAuthentication yes')
			elif (line.find('GSSAPIDelegateCredentials') != -1):
				newContentArray.append('    GSSAPIDelegateCredentials yes')
			elif (line.find('GSSAPITrustDNS') != -1):
				newContentArray.append('    GSSAPITrustDNS yes')
			else:
				newContentArray.append(line)
		# Write our contents to the sshd_config file:
		sshConfigFileContents = '\n'.join(newContentArray)
		sshConfigFileObj = open(sshConfigFilePath,'w')
		sshConfigFileObj.write(sshConfigFileContents)
		sshConfigFileObj.close()
		# Print:
		logger.info('configureKerberosClient: Kerberized SSH configuration.' )
	except:
		logger.info('configureKerberosClient: ERROR: Failed to kerberize SSH configuration.' )

def computerNamingRoutine(shouldAddRandomSuffix):
## Generates random string if requested (shouldAddRandomSuffix).
## Calls pickComputerName() to generate a name per Amazon conventions.
## Sets computer name by calling setComputerName().
	# Default:
	haveSetComputerName = False
	# Pick random suffix if required:
	if shouldAddRandomSuffix:
		# Picks two random digits (letters or numbers)
		randomSuffix = str(uuid.uuid4()).split('-')[1][0:2].lower()
	else:
		randomSuffix = ''
	# Pick a name:
	computerName = pickComputerName(randomSuffix)
	# Set name:
	haveSetComputerName = setComputerName(computerName,adDomain)
	if not haveSetComputerName:
		ipcSendAndPrintMessage('computerNamingRoutine: Problem setting name.',fromHelperSocketPath, azIdentifier)
	else:
		ipcSendAndPrintMessage('Computer name is: ' + computerName,fromHelperSocketPath, azIdentifier)
	# Return:
	return computerName

def main():
## MAIN
	# Open mainDictionary:
	mainDictionary = azLoadMainDictionary()
	# Socket path for initial message:
	toHelperSocketPath = mainDictionary['socketPaths']['adtool']['toHelper']
	# Prefs path:
	assistantPrefsPath = mainDictionary['prefsFile'].replace('~','').replace('__azIdentifier__',azIdentifier).replace('.helper','')
	# Globals:
	global ntpServer, adDomain, adOU, adDomainSearchPath, adTestUserName, adTestUserId, adPluginOptionsDict
	ntpServer = mainDictionary['ntpServer']
	adDomain = mainDictionary['adDomain']
	adOU = mainDictionary['adOU']
	adDomainSearchPath = mainDictionary['adDomainSearchPath']
	adTestUserName = mainDictionary['adTestUserName']
	adTestUserId = mainDictionary['adTestUserId']
	adPluginOptionsDict = mainDictionary['adPluginOptionsDict']
	maxTriesForBinding = mainDictionary['maxTriesForBinding']
	shouldScheduleRestart = mainDictionary['adShouldScheduleRestart']
	minutesBeforeRestart = mainDictionary['adMinutesBeforeRestart']
	maxTriesBeforeComputerNameChange = mainDictionary['maxTriesBeforeComputerNameChange']
	sshConfigFilePath = mainDictionary['sshConfigFilePath']
	kerberosConfigFilePath = mainDictionary['kerberosConfigFilePath']
	kerberosLegacyConfigFilePath = mainDictionary['kerberosLegacyConfigFilePath']
	kerberosConfigFileContentArray = mainDictionary['kerberosConfigFileContentArray']
	# Default states for some variables:
	problem = 'no-problem'
	lastCheck = datetime.datetime.utcnow()
	restartWasScheduled = False
	# Check for root.
	[haveRootUser, userHomePath] = validateUserIsRoot()
	if not haveRootUser:
		# Root required for helper.
		logger.error('This helper must be run by root.')
	else:
		# Try to get message from adtool and validate it.  Assume invalid message.
		validMessage = False
		logger.info('Waiting for message from adtool...')
		[shouldRecieveMessage, messageArray] = ipcReceive(toHelperSocketPath,300)
		if not shouldRecieveMessage:
			problem = 'helper-already-running'
			logger.error('Another instance of this helper is active.  Exiting.')
		else:
			try:
				# Get socket path for replying to adtool:
				global fromHelperSocketPath
				fromHelperSocketPath = messageArray[0]
				action = messageArray[1]
				adBindUser = ''
				adBindPassword = ''
				# Credentials required for configure and remove.
				if action == 'configure' or action == 'remove':
					adBindUser = messageArray[2]
					adBindPassword = messageArray[3]
				# Names and passwords should be less than 33 characters:
				if (len(adBindUser) <= 32) and (len(adBindPassword) <= 32) and (adBindUser.find(' ') == -1) and (adBindUser.find(';') == -1):
					validMessage = True
			except:
				logger.error('Did not receive valid message from adtool.  Exiting.')
		# Check message:
		if not validMessage:
			problem = 'invalid-message'
			logger.error('Invalid message or no response from adtool.')
		else:
			# Message is valid - do initial status checks:
			status, additionalDetails = getADStatus()
			status_prefs = getADPrefsStatus()
			ipcSendAndPrintMessage('Active Directory bind status: ' + status  + '.',fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('Active Directory plugin prefs correct: ' + str(status_prefs)  + '.',fromHelperSocketPath, azIdentifier)
			if action != 'status':
				# FIX-PREFS: Attempt to fix prefs.  Only check that the system is maybe-bound or bound.
				if action == 'fix-prefs':
					if status == 'not-bound':
						# Status is not bound - stop.
						ipcSendAndPrintMessage('ERROR: Cannot set plugin prefs when not bound to Active Directory.',fromHelperSocketPath, azIdentifier)
					else:
						# Status is maybe-bound or bound.  Proceed with setting plugin prefs.
						ipcSendAndPrintMessage('Setting plugin prefs.',fromHelperSocketPath, azIdentifier)
						setDirectoryPluginPrefs()
						status_prefs = True
						ipcSendAndPrintMessage('Plugin prefs set.',fromHelperSocketPath, azIdentifier)
				# SET-COMPUTER-NAME: Just name the computer per Amazon defaults:
				elif action == 'set-computer-name':
					# Set computer name without random characters at end:
					ipcSendAndPrintMessage('Setting computer name.',fromHelperSocketPath, azIdentifier)
					computerName = computerNamingRoutine(False)
				# CONFIGURE: Attempt to bind:
				elif action == 'configure':
					if status == 'bound':
						# Status is bound - stop.
						ipcSendAndPrintMessage('System is already bound to Active Directory.',fromHelperSocketPath, azIdentifier)
					elif status == 'maybe-bound':
						# Status is probably bound, but cannot find a DC - stop.
						ipcSendAndPrintMessage('A domain controller was not located during verification.  This system does not seem to be on the Amazon network.  Connect to the Amazon network and run this tool with the status verb.',fromHelperSocketPath, azIdentifier)
					else:
						# Status is not-bound.  Proceed with configuration.
						# Schedule reboot if required:
						if shouldScheduleRestart:
							ipcSendAndPrintMessage('Computer restart scheduled for ' + str(minutesBeforeRestart) + ' minutes.',fromHelperSocketPath, azIdentifier)
							scheduleReboot(minutesBeforeRestart)
							restartWasScheduled = True
						# Try dsconfigad -remove in case our status of not-bound came about because of a failed test user lookup.
						# In other words, OS X thinks it is bound, but tests indicate otherwise.
						ipcSendAndPrintMessage('Ensuring dsconfigad state is not (yet) bound.',fromHelperSocketPath, azIdentifier)
						unbindFromDomain(adBindUser, adBindPassword)
						# Perform Kerberos client configuration:
						ipcSendAndPrintMessage('Performing Kerberos client configuration.',fromHelperSocketPath, azIdentifier)
						configureKerberosClient(kerberosConfigFilePath, kerberosLegacyConfigFilePath, kerberosConfigFileContentArray, sshConfigFilePath)
						# Set computer name without random characters at end:
						ipcSendAndPrintMessage('Setting computer name.',fromHelperSocketPath, azIdentifier)
						computerName = computerNamingRoutine(False)
						# Binding loop:
						for i in range(0,maxTriesForBinding):
							# Bind.
							ipcSendAndPrintMessage('Running binding routine attempt ' + str(i+1) + ' of ' + str(maxTriesForBinding) + '.',fromHelperSocketPath, azIdentifier)
							bindSuccessful = bindToDomain(computerName, adBindUser, adBindPassword)
							# Verify again.
							if bindSuccessful:
								status, additionalDetails = getADStatus()
								if status == 'bound':
									ipcSendAndPrintMessage('Setting plugin prefs.',fromHelperSocketPath, azIdentifier)
									setDirectoryPluginPrefs()
									status_prefs = True
									ipcSendAndPrintMessage('Plugin prefs set.',fromHelperSocketPath, azIdentifier)
									break
							else:
								ipcSendAndPrintMessage('ERROR: Error while binding to Active Directory.',fromHelperSocketPath, azIdentifier)
								if (i > maxTriesBeforeComputerNameChange) and (i <= maxTriesForBinding):
									# Rename computer using random characters at end:
									ipcSendAndPrintMessage('Changing computer name.',fromHelperSocketPath, azIdentifier)
									computerName = computerNamingRoutine(True)
				# REMOVE: Attempt to unbind.  Does not check status; works in all caseses (even when already not bound).
				elif action == 'remove':
					if shouldScheduleRestart:
						ipcSendAndPrintMessage('Computer restart scheduled for ' + str(minutesBeforeRestart) + ' minutes.',fromHelperSocketPath, azIdentifier)
						scheduleReboot(minutesBeforeRestart)
						restartWasScheduled = True
					for i in range(0,maxTriesForBinding):
						# Unbind.
						ipcSendAndPrintMessage('Unbinding attempt ' + str(i+1) + ' of ' + str(maxTriesForBinding) + '.',fromHelperSocketPath, azIdentifier)
						unbindSuccessful = unbindFromDomain(adBindUser, adBindPassword)
						# Verify again.
						if unbindSuccessful:
							status, additionalDetails = getADStatus()
							if status == 'not-bound':
								status_prefs = False
								break
						else:
							ipcSendAndPrintMessage('ERROR: Error while unbinding from Active Directory.',fromHelperSocketPath, azIdentifier)

			# Follow-up for when action is configure or remove.
			if action in ['configure','remove']:
				# Blank these variables:
				adBindUser = ''
				adBindPassword = ''
				if shouldScheduleRestart and restartWasScheduled:
					# Don't let this script exit if we should restart via scheduled reboot.
					ipcSendAndPrintMessage('Waiting for restart...',fromHelperSocketPath, azIdentifier)
					time.sleep(int(minutesBeforeRestart)*60)
				# Perform secondary verification:
				status, additionalDetails = getADStatus()
				# Skip calling dsconfigad via getADPrefsStatus() again.  This may cause a hang.
				# The status_prefs is modified after each configure anyway.
				ipcSendAndPrintMessage('New Active Directory bind status: ' + status  + '.',fromHelperSocketPath, azIdentifier)
				ipcSendAndPrintMessage('New Active Directory plugin prefs correct: ' + str(status_prefs)  + '.',fromHelperSocketPath, azIdentifier)
			# Tell unprivilged tool that this helper is done:
			ipcSendAndPrintMessage('__closeSocket__',fromHelperSocketPath, azIdentifier)
		# Set prefs keys and update prefs file.
		assistantPrefsDict = {}
		assistantPrefsDict['lastCheck'] = lastCheck
		assistantPrefsDict['problem'] = problem
		# Can only set status information if we got a valid message.
		try:
			assistantPrefsDict['status'] = status
			assistantPrefsDict['status_prefs'] = status_prefs
			assistantPrefsDetailsDict = {}
			assistantPrefsDetailsDict['domainController'] = additionalDetails[0]
			assistantPrefsDetailsDict['computerAccount'] = additionalDetails[1]
			assistantPrefsDetailsDict['resolvedTestUser'] = additionalDetails[2]
			assistantPrefsDict['details'] = assistantPrefsDetailsDict
		except:
			logger.debug('No status to report.  Refer to problems key in ' + assistantPrefsPath +'.')
		azWritePlist(assistantPrefsDict, assistantPrefsPath)

if __name__ == '__main__':
	global azIdentifier
	global logger
	
	azIdentifier = 'com.amazon.acme.helper.adtool'
	logger = azLogger(azIdentifier)
	try:
		main()
	except:
		logger.error('Generic exception.')
