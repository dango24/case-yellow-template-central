#!/System/Library/Frameworks/Python.framework/Versions/Current/bin/python

## helper_accounttool
## Written by Gerrit DeWitt (gerritd@amazon.com)
## Modified by Jason Simmons (jasosimm@amazon.com)
## Version 2.9.8.5 - 2018-10-25 Copyright Amazon

import sys, os, datetime, time
from common_acme import *

## SUBROUTINES

def canBeAdminUser():
## Try gathering details from AD to determine if the user can be an admin.
	# Default:
	canBeAdminFromEmployeeType = False
	canBeAdminFromManagedBy = False
	communicatingWithAd = False
	# Read employee type attribute from original user account record:
	cmd = [ '/usr/bin/dscl','-plist',adDomainSearchPath,'read','/Users/' + user , adEmployeeTypesAttribute ]
	[output,returnCode] = azSubprocess(cmd)
	if returnCode == 0:
		communicatingWithAd = True
		if output:
			dsclOutputDict = azReadPlistFromStr(output)
			if dsclOutputDict:
				try:
					attrValuesArray = dsclOutputDict[adEmployeeTypesAttribute]
					if attrValuesArray:
						for item in attrValuesArray:
							if item in approvedAdminEmployeeTypesArray:
								canBeAdminFromEmployeeType = True
								break
				except KeyError:
					pass
	# Read managedBy attribute from computer account record:
	cmd = [ '/usr/bin/dscl','-plist',adDomainSearchPath,'read','/Computers/' + computerAccount , adManagedByAttribute ]
	[output,returnCode] = azSubprocess(cmd)
	if returnCode == 0:
		communicatingWithAd = True
		if output:
			dsclOutputDict = azReadPlistFromStr(output)
			if dsclOutputDict:
				try:
					attrValuesArray = dsclOutputDict[adManagedByAttribute]
					if attrValuesArray:
						for item in attrValuesArray:
							if userName in item.split(',').split('='):
								canBeAdminFromManagedBy = True
								break
				except KeyError:
					pass
	# Compute canBeAdmin:
	if canBeAdminFromEmployeeType or canBeAdminFromManagedBy:
		canBeAdmin = True
	else:
		canBeAdmin = False
	# Return:
	return communicatingWithAd, canBeAdmin, canBeAdminFromEmployeeType, canBeAdminFromManagedBy

def isAdminUser():
## Returns true if the user is a member of the admin group (GID 80).
	isAdmin = False
	# Call dseditgroup:
	cmd = [ '/usr/sbin/dseditgroup','-o','checkmember','-m',user,'admin' ]
	[output,returnCode] = azSubprocess(cmd)
	if returnCode == 0 and output.lower().find('is a member of admin') != -1:
		isAdmin = True
	return isAdmin

def getAccountStatus():
# Determines status of the user account; indeterminate is the default.
# If an admin already: return is-admin.
# Else:
# 	If no AD communication: status stays at indeterminate; note problem.
# 	If AD communication:
# 		Return admin-eligible if the user is eligible.
# 		Return not-admin-eligible otherwise.
	# Default:
	status = 'indeterminate'
	# Check for admin membership:
	isAdmin = isAdminUser()
	ipcSendAndPrintMessage('getAccountStatus: admin membership: ' + str(isAdmin),fromHelperSocketPath, azIdentifier)
	if isAdmin:
		status = 'is-admin'
	else:
		# If not an admin, check eligibility:
		[communicatingWithAd, canBeAdmin, canBeAdminFromEmployeeType, canBeAdminFromManagedBy] = canBeAdminUser()
		ipcSendAndPrintMessage('getAccountStatus: AD communication: ' + str(communicatingWithAd),fromHelperSocketPath, azIdentifier)
		if not communicatingWithAd:
			problem = 'no-communication-with-ad'
		else:
			ipcSendAndPrintMessage('getAccountStatus: eligible to be an admin: ' + str(canBeAdmin),fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('getAccountStatus: eligiblity from employee type: ' + str(canBeAdminFromEmployeeType),fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('getAccountStatus: eligiblity from managedBy: ' + str(canBeAdminFromManagedBy),fromHelperSocketPath, azIdentifier)
			if canBeAdmin:
				status = 'admin-eligible'
			else:
				status = 'not-admin-eligible'
	# Return:
	return status

def demoteAdmin():
## Attempts to remove the user from the admin group.  Returns true if successful.
	# Defaults:
	membershipUpdated = False
	flushedCaches = False
	# Update group membership:
	cmd = ['/usr/sbin/dseditgroup','-o','edit','-d',user,'admin']
	[output,returnCode] = azSubprocess(cmd)
	if ( returnCode == 0 ):
		membershipUpdated = True
	# Flush caches:
	cmd = ['/usr/bin/dscacheutil','-flushcache']
	[output,returnCode] = azSubprocess(cmd)
	if ( returnCode == 0 ):
		flushedCaches = True
	# If successful, wait and re-run isAdminUser():
	time.sleep(10)
	# Return:
	if membershipUpdated and flushedCaches and (not isAdminUser()):
		return True
	else:
		return False

def promoteAdmin():
## Attempts to add the user to the admin group.  Returns true if successful.
	# Defaults:
	membershipUpdated = False
	flushedCaches = False
	# Update group membership:
	cmd = ['/usr/sbin/dseditgroup','-o','edit','-a',user,'-t','user','admin']
	[output,returnCode] = azSubprocess(cmd)
	if ( returnCode == 0 ):
		membershipUpdated = True
	# Flush caches:
	cmd = ['/usr/bin/dscacheutil','-flushcache']
	[output,returnCode] = azSubprocess(cmd)
	if ( returnCode == 0 ):
		flushedCaches = True
	# If successful, wait and re-run isAdminUser():
	time.sleep(10)
	# Return:
	if membershipUpdated and flushedCaches and isAdminUser():
		return True
	else:
		return False

def main():
## MAIN
	# Open mainDictionary:
	mainDictionary = azLoadMainDictionary()
	# Socket path for initial message:
	toHelperSocketPath = mainDictionary['socketPaths']['accounttool']['toHelper']
	# Prefs path:
	assistantPrefsPath = mainDictionary['prefsFile'].replace('~','').replace('__azIdentifier__',azIdentifier).replace('.helper','')
	# Globals:
	global adDomain, adDomainSearchPath, adTestUserName, adTestUserId, adPluginOptionsDict
	global approvedAdminEmployeeTypesArray, adDomainSearchPath, adEmployeeTypesAttribute, adManagedByAttribute
	adDomain = mainDictionary['adDomain']
	adDomainSearchPath = mainDictionary['adDomainSearchPath']
	approvedAdminEmployeeTypesArray = mainDictionary['approvedAdminEmployeeTypes']
	adDomainSearchPath = mainDictionary['adDomainSearchPath']
	adEmployeeTypesAttribute = mainDictionary['adEmployeeTypesAttribute']
	adManagedByAttribute = mainDictionary['adManagedByAttribute']
	global user, computerAccount
	# Default states for some variables:
	problem = 'no-problem'
	lastCheck = datetime.datetime.utcnow()
	# Check for root.
	[haveRootUser, userHomePath] = validateUserIsRoot()
	if not haveRootUser:
		# Root required for helper.  No need to write this as a problem.
		logger.error('This helper must be run by root.')
	else:
		# Try to get message from accounttool and validate it.  Assume invalid message.
		validMessage = False
		logger.info('Waiting for message from accounttool...')
		[shouldRecieveMessage, messageArray] = ipcReceive(toHelperSocketPath,10)
		if not shouldRecieveMessage:
			problem = 'helper-already-running'
			logger.error('Another instance of this helper is active.  Exiting.')
		else:
			try:
				# Get socket path for replying to accounttool:
				global fromHelperSocketPath
				fromHelperSocketPath = messageArray[0]
				action = messageArray[1]
				user = messageArray[2]
				# Names and passwords should be less than 33 characters:
				if len(user) <= 32:
					validMessage = True
			except:
				logger.error('Did not receive valid message from accounttool.  Exiting.')
		# Check message:	
		if not validMessage:
			problem = 'invalid-message'
			logger.error('Invalid message or no response from accounttool.')
		else:
			# Message is valid:
			ipcSendAndPrintMessage('Requested user: ' + user  + '.',fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('Requested action: ' + action  + '.',fromHelperSocketPath, azIdentifier)
			# When asked to configure or remove, check AD connectivity:
			[computerAccountValid, computerAccount] = validateComputerAccount(adDomainSearchPath)
			# If not bound:
			if not computerAccountValid:
				problem = 'no-communication-with-ad'
				ipcSendAndPrintMessage('This computer does not seem to be bound to Active Directory. Fix that problem then try again.',fromHelperSocketPath, azIdentifier)
			# Get and report status:
			status = getAccountStatus()
			ipcSendAndPrintMessage('Status for user: ' + status  + '.',fromHelperSocketPath, azIdentifier)
			if action != 'status':
				# Attempt to configure:
				if action == 'configure':
					if status == 'admin-eligible':
						ipcSendAndPrintMessage('Running routine for granting admin rights.  Please wait.',fromHelperSocketPath, azIdentifier)
						promoteAdmin()
					elif status == 'is-admin':
						ipcSendAndPrintMessage('Account already has admin rights.',fromHelperSocketPath, azIdentifier)
					else: # Not admin-eligible:
						ipcSendAndPrintMessage('Account ineligible for admin rights.',fromHelperSocketPath, azIdentifier)
				# Attempt to remove:
				elif action == 'remove':
					if status != 'is-admin':
						ipcSendAndPrintMessage('Account already lacks admin rights.',fromHelperSocketPath, azIdentifier)
					else:
						ipcSendAndPrintMessage('Running routine for removing admin rights.  Please wait.',fromHelperSocketPath, azIdentifier)
						demoteAdmin()							
				# Final verification:
				ipcSendAndPrintMessage('Running final verification.',fromHelperSocketPath, azIdentifier)
				status = getAccountStatus()
				ipcSendAndPrintMessage('New status for user: ' + status  + '.',fromHelperSocketPath, azIdentifier)
			# Tell unprivilged tool that this helper is done:
			ipcSendAndPrintMessage('__closeSocket__',fromHelperSocketPath, azIdentifier)
		# Set prefs keys and update prefs file.
		# Try to update the file instead of overwriting it.
		assistantPrefsDict = azReadPlist(assistantPrefsPath)
		assistantPrefsDict['lastCheck'] = lastCheck
		assistantPrefsDict['problem'] = problem
		# Can only set user status information if we got a valid message.
		try:
			assistantPrefsSubDictForUser = {}
			assistantPrefsSubDictForUser['status'] = status
			assistantPrefsDict[user] = assistantPrefsSubDictForUser
		except:
			logger.debug('No status to report.  Refer to problems key in ' + assistantPrefsPath +'.')
		azWritePlist(assistantPrefsDict, assistantPrefsPath)

if __name__ == '__main__':
	global azIdentifier
	global logger

	azIdentifier = 'com.amazon.acme.helper.accounttool'
	logger = azLogger(azIdentifier)

	try:
		main()
	except:
		logger.error('Generic exception.')
