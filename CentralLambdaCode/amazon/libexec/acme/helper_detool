#!/System/Library/Frameworks/Python.framework/Versions/Current/bin/python

## helper_detool
## Written by Gerrit DeWitt (gerritd@amazon.com)
## Modified by Jason Simmons (jasosimm@amazon.com)
## Modified by LJ Cline (joscline@amazon.com)
## Version 2.9.8.5 - 2018-10-25 Copyright Amazon
## Script for managing FileVault.  Serves as the privileged helper for detool.
## Builds on the FileVault Monitor by Beau Hunter (beauhunt@amazon.com).

## Detool services 3 methods of Filevault on macOS
# HFS (Any OS Version)
# APFS with Disk user (High Sierra upgrades)
# APFS with ADMIN user (High Sierra injection/DEP)


#Caveats
#Machines upgraded to High Sierra APFS do not receive a securetoken account, therefore new users are unable to be added to filevault (event after attempting to authenticate with DISK password)
#This is due to our "non-standard" implementation of Filevault on HFS systems.

#Machines injected on High Sierra are granted a securetoken to the first user 'tokenadmin' , and the managed ADMIN account, and the first AD user via ACME and the initial tokenadmin credentials. After the AD account has been added, the tokenadmin account is removed for security reasons.

from __future__ import unicode_literals
import os, sys, shutil, time, datetime
import pexpect
from common_acme import *
from common_acme_crypto import *


## SUBROUTINES
def updateAPFSPreboot():
	ipcSendAndPrintMessage('Updating APFS preboot partition.',fromHelperSocketPath, azIdentifier)
	cmd = ['/usr/sbin/diskutil', 'apfs', 'updatepreboot', '/']
	try:
		[output,returnCode] = azSubprocess(cmd)
	except:
		logger.error('updateAPFSPreboot: APFS Preboot update failure')

def grantSecureToken(initialSecureTokenAdmin, initialSecureTokenPass, userName, userPassword):
	logger.info('grantSecureToken: Granting ' + userName + ' securetoken rights to unlock Filevault')
	#using pexpect to mask the user credentials.
	cmd = '/usr/sbin/sysadminctl'
	args = ['-adminUser', initialSecureTokenAdmin, '-adminPassword', initialSecureTokenPass, '-secureTokenOn', userName, '-password', '-']
	child = pexpect.spawn(cmd, args, timeout=30)
	# Enter the user password
	child.expect('Enter password for *')
	child.sendline(userPassword)
	child.read(size=-1)
	child.close()
	if child.before.lower().find('error') == -1: # Did not find the word "error."
		logger.info('GrantSecureToken: SecureToken granted for ' + userName + '')
		return True
	else:
		logger.error('GrantSecureToken: Unable to grant SecureToken for ' + userName + '')
		return False

def isDiskEncryptionRequired(computerType):
## Returns true iff FileVault is required.
	logger.info('isDiskEncryptionRequired: Determining if disk encyption is required')
	exemptMacIdentifiers = mainDictionary['fileVaultConfigDict']['exemptMacIdentifiers']
	exemptionSemaphore = mainDictionary['fileVaultConfigDict']['exemptionSemaphore']
	# Default - assume encryption is required unless an exemption is found:
	bootVolumeEncryptionRequired = True
	exemptByIdentifier = False
	exemptBySemaphore = False
	# Check for exemption by model identifier:
	for exemptMacIdentifier in exemptMacIdentifiers:
		if computerType.lower().startswith(exemptMacIdentifier.lower()):
			bootVolumeEncryptionRequired = False
			exemptByIdentifier = True
			logger.info('Encryption not required, not a mobile computer')
			break
	# Check for exemption by semaphore file:
	if os.path.exists(exemptionSemaphore):
		bootVolumeEncryptionRequired = False
		exemptBySemaphore = True
		logger.info('Encryption not required, exemption semaphore found')
	# Return:
	return bootVolumeEncryptionRequired, exemptByIdentifier, exemptBySemaphore

def bootVolumeFileVaultStatus():
## Get CoreStorage details for the startup disk.
	# Defaults:
	fileSystemType = 'invalid'
	bootVolumeUUID = 'invalid'
	bootVolumeFamilyUUID = 'invalid'
	bootVolumeConversionStatus = 'invalid'
	bootVolumeFamilyEncType = 'invalid'
	apfsDiskUserEnabled = False
	# Assume encryption is off:
	bootVolumeEncryptionEnabled = False
	logger.info('bootVolumeFileVaultStatus: Determining local disk filesystem format')
	# Run diskutil to get volume info:
	cmd = ['/usr/sbin/diskutil','info','-plist','/']
	[output,returnCode] = azSubprocess(cmd)
	if output:
		outputArray = azReadPlistFromStr(output)
		if outputArray:
			try:
				fileSystemType = outputArray['FilesystemType']
			except KeyError:
				logger.error('bootVolumeFileVaultStatus: Cannot get Filesystem format details for startup volume.')
			if fileSystemType == 'apfs':
				logger.info('Disk format is APFS.')
				try:
					apfsVolumeUUID = outputArray['VolumeUUID']
					logger.info('bootVolumeFileVaultStatus: Volume UUID is ' + apfsVolumeUUID+ '.')
				except KeyError:
					logger.error('bootVolumeFileVaultStatus: Cannot get Volume UUID for startup volume.')
				cmd = ['/usr/sbin/diskutil', 'apfs', 'listUsers', '-plist', '/']
				[output,returncode] = azSubprocess(cmd)
				logger.info('bootVolumeFileVaultStatus: Determining if APFS DISK user is enabled')
				outputArray = azReadPlistFromStr(output)
				userArray = outputArray['Users']
				if any (d['APFSCryptoUserType'] == 'Disk' for d in userArray):
					apfsDiskUserEnabled = True
					logger.info('bootVolumeFileVaultStatus: APFS DISK user identified')
				else:
					logger.info('bootVolumeFileVaultStatus: APFS DISK user absent, presuming injection or DEP provisioned')
			elif fileSystemType == 'hfs':
				logger.info('Disk format is HFS.')
	if fileSystemType == 'hfs':
		logger.info('bootVolumeFileVaultStatus: Determining HFS encryption status')
		cmd = ['/usr/sbin/diskutil','cs','info','-plist','/']
		[output,returnCode] = azSubprocess(cmd)
		if output:
			outputArray = azReadPlistFromStr(output)
			if outputArray:
				try:
					# Try to get details for logical volume:
					bootVolumeUUID = outputArray['CoreStorageUUID']
					bootVolumeFamilyUUID = outputArray['MemberOfCoreStorageLogicalVolumeFamily']
					bootVolumeConversionStatus = outputArray['CoreStorageLogicalVolumeConversionState']
					logger.info('bootVolumeFileVaultStatus: CoreStorage Boot Volume UUID ' + str(bootVolumeUUID) + '')
				except KeyError:
					logger.error('bootVolumeFileVaultStatus: Cannot get CoreStorage details for startup volume.')
		# Should be CoreStorage:
		if bootVolumeFamilyUUID != 'invalid':
			# Run diskutil to get family info:
			cmd = ['/usr/sbin/diskutil','cs','info','-plist',bootVolumeFamilyUUID]
			[output2,returnCode] = azSubprocess(cmd)
			if output2:
				outputArray2 = azReadPlistFromStr(output2)
				if outputArray2:
					try:
						# Try to get details for family:
						bootVolumeFamilyEncType = outputArray2['CoreStorageLogicalVolumeFamilyEncryptionType']
						if bootVolumeFamilyEncType == 'AES-XTS':
							bootVolumeEncryptionEnabled = True
							logger.info('bootVolumeFileVaultStatus: HFS encryption state ' + str(bootVolumeEncryptionEnabled) + '')
					except KeyError:
							logger.error('bootVolumeFileVaultStatus: Cannot get encryption type for volume family.')
	elif fileSystemType == 'apfs':
		logger.info('bootVolumeFileVaultStatus: Determining AFPS encryption status')
		global apfsDeviceIdentifier
		cmd = ['/usr/sbin/diskutil','apfs','list','-plist']
		[output,returnCode] = azSubprocess(cmd)
		if output:
			outputArray = azReadPlistFromStr(output)
			if outputArray:
				apfsBootVolumeData = outputArray['Containers'][0]['Volumes'][0]
				apfsDeviceIdentifier = apfsBootVolumeData['DeviceIdentifier']
				bootVolumeUUID = apfsBootVolumeData['APFSVolumeUUID']
				try:
					apfsEncryptionState = apfsBootVolumeData['FileVault']
				except KeyError:
						logger.error('bootVolumeFileVaultStatus: exception detecting encryption state')
						try:
							apfsEncryptionState = apfsBootVolumeData['Encryption Progress']
						except KeyError:
								logger.error('bootVolumeFileVaultStatus: exception detecting encryption progress')
				logger.info('bootVolumeFileVaultStatus: APFS encryption state ' + str(apfsEncryptionState) + '')
				if apfsEncryptionState == True:
					bootVolumeEncryptionEnabled = True
					bootVolumeFamilyEncType = 'APFS'
					bootVolumeConversionStatus = 'Complete'
				elif apfsEncryptionState != True:
					bootVolumeEncryptionEnabled = False
					bootVolumeFamilyEncType = 'APFS'
					bootVolumeConversionStatus = 'Unknown'
	# Return:
	return bootVolumeEncryptionEnabled, bootVolumeUUID, bootVolumeFamilyUUID, bootVolumeConversionStatus, bootVolumeFamilyEncType, fileSystemType, apfsDiskUserEnabled

def fileVaultUserStatus(requestedUser, fileSystemType, apfsDiskUserEnabled):
## Determine if any users are provisioned for FileVault
## and if the current user (if any) can be provisioned.
	logger.info('fileVaultUserStatus: Determining filevault user status')
	adDomain = mainDictionary['adDomain']
	# Defaults:
	diskUnlockUserList = []
	requestedUserCanUnlockDisk = False
	requestedUserIsValid = False
	# Run fdesetup to get user list:
	cmd = ['/usr/bin/fdesetup','list']
	[output,returnCode] = azSubprocess(cmd)
	try:
		outputArray = output.split('\n')
		for line in outputArray:
			userName = line.split(',')[0]
			# Exclude blank lines from CLI output:
			if userName != '':
				diskUnlockUserList.append(userName)
	except:
		logger.debug('fileVaultUserStatus: No users appear able to unlock the disk.')
	# Validate the requested user.  If not supplied, try validating the Aqua session user.
	if requestedUser != 'try-session-user':
		requestedUserIsValid = userIsAdUser(requestedUser,adDomain)
	else:
		# No user specified:  Get the current Aqua session user if possible: WIP - what if no one is logged in?
		[requestedUserIsValid, requestedUser, userHomePath] = validateUserFromSystemContext(adDomain)
	# Determine if the current user is in the user list (provided that the user list isn't empty):
	# Future Improvement -  Check UUID too?
	if diskUnlockUserList:
		if requestedUser in diskUnlockUserList:
			requestedUserCanUnlockDisk = True
	if requestedUserCanUnlockDisk == False and fileSystemType == 'apfs' and apfsDiskUserEnabled == True:
		requestedUserIsValid = False
	# Return:
	logger.info('fileVaultUserStatus: Users able to unlock boot disk ' + str(diskUnlockUserList))
	logger.info('fileVaultUserStatus: User is valid ' + str(requestedUserIsValid))
	logger.info('fileVaultUserStatus: User can unlock disk ' + str(requestedUserCanUnlockDisk))
	return diskUnlockUserList, requestedUserIsValid, requestedUserCanUnlockDisk

def enableFileVaultOnBootVolume(fileSystemType):
## Converts the startup volume to a CoreStorage
## Logical Volume with a Disk Password.
	logger.info('enableFileVaultOnBootVolume: Executing enable filevault routine')
	defaultDiskPassword = mainDictionary['fileVaultConfigDict']['defaultDiskPassword']
	conversionStarted = False
	if fileSystemType == 'hfs':
		# Defaults:
		# Run diskutil to encrypt the startup volume:
		try:
			logger.info('enableFileVaultOnBootVolume: Enabling Filevault on HFS boot volume')
			cmd = '/usr/sbin/diskutil'
			args = ['cs', 'convert', '/', '-passphrase']
			child = pexpect.spawn(cmd, args, timeout=30)
			# Enter the password twice:
			child.expect('New passphrase for converted volume:')
			child.sendline(defaultDiskPassword)
			child.expect('Confirm new passphrase:')
			child.sendline(defaultDiskPassword)
			# Block on diskutil execution:
			child.read(size=-1)
			child.close()
			# Inspect diskutil output.  Success looks like:
			# ....
			# Finished CoreStorage operation on <disk identifier> <vol name>
			# Encryption in progress; use `diskutil coreStorage list` for status
			if child.before.lower().find('finished corestorage operation') != -1: # Found this phrase.
				ipcSendAndPrintMessage('enableFileVaultOnBootVolume: Successfully enabled FileVault on startup device.',fromHelperSocketPath, azIdentifier)
				conversionStarted = True
			if child.before.lower().find('69753') != -1: # Found this phrase.
				ipcSendAndPrintMessage('enableFileVaultOnBootVolume: Corestorage enabled already.',fromHelperSocketPath, azIdentifier)
				conversionStarted = True
			# Common failure meaning the startup disk is already converted:
			# Error converting disk to CoreStorage: Stacked Core Storage Sets are not supported (-69754)
			if child.before.lower().find('stacked core storage sets are not supported (-69754)') != -1: # Found this phrase.
				ipcSendAndPrintMessage('enableFileVaultOnBootVolume: Startup disk is already CoreStorage.',fromHelperSocketPath, azIdentifier)
		except:
			ipcSendAndPrintMessage('enableFileVaultOnBootVolume: HFS diskutil timed out or failed.',fromHelperSocketPath, azIdentifier)
	elif fileSystemType == 'apfs':
		# Defaults:
		initialSecureTokenAdmin = mainDictionary['fileVaultConfigDict']['initialSecureTokenAdmin']
		initialSecureTokenPass = mainDictionary['fileVaultConfigDict']['initialSecureTokenPass']
		localAdminAccount = mainDictionary['localAdminAccountConfigDict']['localAdminAccountAttrDict']['RecordName']
		try:
			#Need to unlock keychain before extracting intial password for provisioning
			logger.info('enableFileVaultOnBootVolume: Retrieving initial admin password to add to filevault')
			cmd = '/usr/bin/security'
			args = ['unlock-keychain', '/private/var/tmp/AmazonProvisioner.keychain']
			child = pexpect.spawn(cmd, args, timeout=60)
			child.expect('password to unlock*')
			child.sendline('')
			child.close()
			#retrieve initial password to add admin user to filevault
			kcPassword = getPasswordFromKeychain('com.amazon.initial.admin.password','/private/var/tmp/AmazonProvisioner.keychain')
			if kcPassword != 'invalid-password':
				try:
					#grant securetoken rights to the admin user before adding it to filevault
					if grantSecureToken(initialSecureTokenAdmin, initialSecureTokenPass, localAdminAccount, kcPassword):
						logger.info('enableFileVaultOnBootVolume: Enabling Filevault on APFS boot volume')
						#run fdesetup to add the admin user to filevault.
						cmd = '/usr/bin/fdesetup'
						args = ['enable', 'add']
						child = pexpect.spawn(cmd, args, timeout=30)
						# Enter the disk password:
						child.expect('Enter the user name:*')
						child.sendline(localAdminAccount)
						# Enter the user's password:
						child.expect('Enter the password for user*')
						child.sendline(kcPassword)
						# Block on fdesetup execution:
						child.read(size=-1)
						child.close()
						# Inspect fdesetup output; the tool exits with status zero.
						# Common errors are:
						# Error: Unable to add user 'name' to existing FileVault because the user could not be found.
						# Error: Unable to add user 'name' to existing FileVault because the user could not be authenticated.
						if child.before.lower().find('error: ') == -1: # Did not find the word "error."
							conversionStarted = True
							#update APFS preboot to ensure ADMIN user password is synced
							updateAPFSPreboot()
							#disable filevault automatic login after adding admin user
							cmd = ['/usr/bin/defaults','write', loginWindowPlist, 'DisableFDEAutoLogin', '-bool', 'YES' ]
							[output,returnCode] = azSubprocess(cmd)
							if returnCode == 0:
								logger.info('enableFilevaultOnBootVolume: Disabled Filevault auto login for initial provisioning')
							else:
								logger.info('enableFilevaultOnBootVolume: Filevault auto login currently disabled ')
							#remove the initial admin keychain contents
							if os.path.exists('/private/var/tmp/AmazonProvisioner.keychain'):
								os.remove('/private/var/tmp/AmazonProvisioner.keychain')
							cmd = ['/usr/sbin/dseditgroup','-o','edit','-d','tokenadmin','admin']
							[output,returnCode] = azSubprocess(cmd)
							if returnCode == 0:
								logger.info('enableFileVaultOnBootVolume: Tokenadmin demoted from system admin')
							else:
								logger.error('enableFileVaultOnBootVolume: could not demote Tokenadmin account')
						else:
							logger.error('enableFilevaultOnBootVolume: Unable to initialize Filevault and add admin user')
					else:
						logger.error('Unable to grant securetoken')
				except:
					logger.error('enableFilevaultOnBootVolume: Unable to enable filevault for Admin user')
			else:
				logger.error('enableFilevaultOnBootVolume: Initial admin password missing from keychain')
		except:
			ipcSendAndPrintMessage('enableFileVaultOnBootVolume: Diskutil APFS timeout or failure',fromHelperSocketPath, azIdentifier)
	# Return:
	return conversionStarted
	
def addUserToFileVault(userName, userPassword, suppliedUnlockPassword,fileSystemType,apfsDiskUserEnabled):
	# Default:
	fdesetupFinished = False
	logger.info('Adding ' + userName + ' to ' + str(fileSystemType) + ' filevault')
	if fileSystemType == 'hfs':
		## Adds the specified user to the list of users who can unlock the disk.
		defaultDiskPassword = mainDictionary['fileVaultConfigDict']['defaultDiskPassword']
		# Get current disk password from system keychain:
		currentDiskPassword = getPasswordFromKeychain('com.amazon.DiskPassword.current',systemKeychainPath)
		# Create an array of disk password candidates:  Order is:
		# 1st - Disk password in the system keychain (com.amazon.DiskPassword.current).
		# 2nd - Default disk password (newly imaged system?)
		# 3rd - A disk unlock password as entered by the user (via detool).
		unlockPasswordArray = [currentDiskPassword,defaultDiskPassword]
		if suppliedUnlockPassword != 'not-supplied':
			unlockPasswordArray.append(suppliedUnlockPassword)
		# Try adding the user by authorizing with each password candidate:
		for anUnlockPassword in unlockPasswordArray:
			try:
				# Run fdesetup:
				cmd = '/usr/bin/fdesetup'
				args = ['add', '-usertoadd', userName]
				child = pexpect.spawn(cmd, args, timeout=30)
				# Enter the disk password:
				child.expect('Enter a password for .*')
				child.sendline(anUnlockPassword)
				# Enter the user's password:
				child.expect('Enter the password for the added user .*')
				child.sendline(userPassword)
				# Block on fdesetup execution:
				child.read(size=-1)
				child.close()
				# Inspect fdesetup output; the tool exits with status zero.
				# Common errors are:
				# Error: Unable to add user 'name' to existing FileVault because the user could not be found.
				# Error: Unable to add user 'name' to existing FileVault because the user could not be authenticated.
				if child.before.lower().find('error: ') == -1: # Did not find the word "error."
					fdesetupFinished = True
					cmd = ['/usr/bin/defaults', 'delete', loginWindowPlist, 'DisableFDEAutoLogin' ]
					[output,returnCode] = azSubprocess(cmd)
					if returnCode == 0:
						logger.info('addUserToFileVault: Enabled Filevault auto login for registered user')
					else:
						logger.info('addUserToFileVault: Filevault auto login already enabled')
					break
			except:
				ipcSendAndPrintMessage('addUserToFileVault: HFS fdesetup timed out or failed.',fromHelperSocketPath, azIdentifier)
	elif fileSystemType == 'apfs' and apfsDiskUserEnabled == False:
		try:
			initialSecureTokenAdmin = mainDictionary['fileVaultConfigDict']['initialSecureTokenAdmin']
			initialSecureTokenPass = mainDictionary['fileVaultConfigDict']['initialSecureTokenPass']
			#Promote tokenadmin to system admin temporarily to grant securetoken
			cmd = ['/usr/sbin/dseditgroup','-o','edit','-a','tokenadmin','-t','user','admin']
			[output,returnCode] = azSubprocess(cmd)
			if returnCode == 0:
				logger.info('addUserToFileVault: Tokenadmin temporarily promoted to admin to grant securetoken')
			else:
				logger.error('addUserToFileVault: Failed to temporarily promote tokenadmin to admin status.')
			#Need to grant AD user secureTokenOn status, or else user will not be able to be added to filevault
			if grantSecureToken(initialSecureTokenAdmin, initialSecureTokenPass, userName, userPassword):
				cmd = '/usr/bin/fdesetup'
				args = ['add', '-usertoadd', userName]
				child = pexpect.spawn(cmd, args, timeout=30)
				# Enter the initial tokenadmin credentials to authorize adding to filevault
				try:
					child.expect('Enter the user name*')
					child.sendline(initialSecureTokenAdmin)
					child.expect('Enter the password for user*')
					child.sendline(initialSecureTokenPass)
					# Enter the user's password:
					child.expect('Enter the password for the added user*')
					child.sendline(userPassword)
				except:
					logger.error('Unexpected return when adding user to APFS Filevault')
				# Block on fdesetup execution:
				child.read(size=-1)
				child.close()
				# Inspect fdesetup output; the tool exits with status zero.
				# Common errors are:
				# Error: Unable to add user 'name' to existing FileVault because the user could not be found.
				# Error: Unable to add user 'name' to existing FileVault because the user could not be authenticated.
				if child.before.lower().find('error: ') == -1: # Did not find the word "error."
					fdesetupFinished = True
					#update APFS preboot to sync user password and picture
					updateAPFSPreboot()
					#Enable Filevault auto login for authenticated user
					cmd = ['/usr/bin/defaults', 'delete', loginWindowPlist, 'DisableFDEAutoLogin' ]
					[output,returnCode] = azSubprocess(cmd)
					if returnCode == 0:
						logger.info('addUserToFileVault: Enabled Filevault auto login for registered user')
					else:
						logger.info('addUserToFileVault: Filevault auto login already enabled')
					logger.info('Removing initial securetoken admin account')
					if deleteAccount(initialSecureTokenAdmin):
						logger.info('Initial securetoken admin removed')
					else:
						logger.error('Unable to remove initial securetoken admin account')
				else:
					logger.error('Unexpected return from reading pexpect child')
			else:
				logger.error('unable to grant securetoken')
		except:
			ipcSendAndPrintMessage('addUserToFileVault: APFS fdesetup timed out or failed.',fromHelperSocketPath, azIdentifier)
	elif	fileSystemType == 'apfs' and apfsDiskUserEnabled == True:
		ipcSendAndPrintMessage('addUserToFileVault: Cannot add new user to APFS Filevault, no securetoken admin present',fromHelperSocketPath, azIdentifier)
		fdesetupFinished = True
	# Return:
	return fdesetupFinished

def shouldSetDiskPassword(status_disk_password, status_user_list, fileSystemType, apfsDiskUserEnabled):
	logger.info('shouldSetDiskPassword: Determining if password should be set')
	## Returns true if the Disk Password should be changed.
	if fileSystemType == 'hfs' or fileSystemType == 'apfs' and apfsDiskUserEnabled == True:
		idealMaximumLifeOfDefaultPassword = mainDictionary['fileVaultConfigDict']['idealMaximumLifeOfDefaultPassword']
		diskPasswordRotationInterval = mainDictionary['fileVaultConfigDict']['diskPasswordRotationInterval']
		# Defaults - Assume false unless proven otherwise:
		passwordChangeRequired = False
		nowPoint = datetime.datetime.utcnow()
		historyPrefsPath = mainDictionary['fileVaultConfigDict']['historyPrefsPath']
		historyPrefsDict = azReadPlist(historyPrefsPath)
		# When is a disk password change required?
		# CASE 1: After imaging case: The disk password is the default.
		# Rotate the disk password for HFS
		if status_disk_password == 'default-password':
			# CASE 1A: At least one user can unlock the disk:
			if status_user_list:
				# Skip any date checks and change the disk password now:
				ipcSendAndPrintMessage('shouldSetDiskPassword: Default disk password and one or more users are provisioned.',fromHelperSocketPath, azIdentifier)
				passwordChangeRequired = True
			# No users provisioned for FileVault:
			else:
				# Read last changed date from the history file:
				try:
					diskPasswordLastChanged = historyPrefsDict['diskPasswordLastChanged']
					ipcSendAndPrintMessage('shouldSetDiskPassword: Disk password last changed: '+str(diskPasswordLastChanged),fromHelperSocketPath, azIdentifier)
				except:
					# Missing diskPasswordLastChanged or history file.
					# This is expected on the tool's first run after imaging.
					# Set the last changed point to now and save it.
					diskPasswordLastChanged = nowPoint
					azWritePlist(historyPrefsDict, historyPrefsPath)
				# CASE 1B: No users are provisioned, but the system has had a default password for too long:
				if abs(nowPoint - diskPasswordLastChanged) >= datetime.timedelta(seconds=int(idealMaximumLifeOfDefaultPassword)):
					ipcSendAndPrintMessage('shouldSetDiskPassword: Default disk password, no users provisioned, but the ideal maximum life of the default password has been reached.',fromHelperSocketPath, azIdentifier)
					passwordChangeRequired = True
		# CASE 2: Periodically: The disk password is not the default.  It has changed at least once.
		elif status_disk_password == 'not-default-password':
			# Read last changed date from the history file:
			try:
				diskPasswordLastChanged = historyPrefsDict['diskPasswordLastChanged']
			except:
				# Missing diskPasswordLastChanged or history file; set last changed to X days ago so as to force a change now.
				# Most common case: systems deployed with previous automations that set unique passwords.
				diskPasswordLastChanged = nowPoint - datetime.timedelta(seconds=int(diskPasswordRotationInterval))
				azWritePlist(historyPrefsDict, historyPrefsPath)
			# Display diskPasswordLastChanged:
			ipcSendAndPrintMessage('shouldSetDiskPassword: Disk password last changed: '+str(diskPasswordLastChanged),fromHelperSocketPath, azIdentifier)
			# If difference between now and last change is long enough:
			if abs(nowPoint - diskPasswordLastChanged) >= datetime.timedelta(seconds=int(diskPasswordRotationInterval)):
				ipcSendAndPrintMessage('shouldSetDiskPassword: Periodic: Disk password should be rotated.',fromHelperSocketPath, azIdentifier)
				passwordChangeRequired = True
	#Disk password does not exist for APFS Injections, we will be rotating ADMIN user password via pyacme
	elif fileSystemType == 'apfs' and apfsDiskUserEnabled == False or status_disk_password == 'admin-provisioned':
		passwordChangeRequired = False
		logger.info('shouldSetDiskPassword: Disk password rotation unnecessary')
	else:
		logger.error('shouldSetDiskPassword: Unable to determine if disk password should be rotated')
	# Return:
	return passwordChangeRequired

def generateAndEscrowNextDiskPassword(status_encryption,status_disk_password):
## Creates a new FileVault Disk Password, stores it in the System keychain,
## and stores an encrypted version in the password history file.
	logger.info('Escrow: Executing generate and escrow routine')
	pubKeyFilePath = mainDictionary['fileVaultConfigDict']['pubKeyFilePath']
	historyPrefsPath = mainDictionary['fileVaultConfigDict']['historyPrefsPath']
	historyPrefsPathBackup = mainDictionary['fileVaultConfigDict']['historyPrefsPathBackup']
	# Defaults:
	escrowedNextDiskPassword = False
	escrowedNextDiskPasswordE = False
	#backup the current history file before we escrow, we will gather these details via jamf for redundancy
	timestr = time.strftime("%Y%m%d-%H%M%S")
	newHistoryPath = os.path.join(historyPrefsPathBackup, timestr + '.plist')
	if not os.path.exists(historyPrefsPathBackup):
		os.makedirs(historyPrefsPathBackup)
	try:
		shutil.copy(historyPrefsPath,newHistoryPath)
	except:
		logger.error('Escrow: Could not backup detool history file')
	#Verification steps before running
	#If the diskpassword current in keychain is missing and filevault is enabled do not attempt to escrow. If the password is still the default password we will rotate (freshly imaged system)
	currentDiskPassword = getPasswordFromKeychain('com.amazon.DiskPassword.current',systemKeychainPath)
	if currentDiskPassword != 'invalid-password' and status_encryption == True or status_disk_password == 'default-password':
		logger.info('Escrow: Begining disk password escrow')
		# STEP 1A: Generate new password using randompassword binary (/dev/urandom source):
		cmd = ['/usr/local/amazon/libexec/acme/randompassword']
		[output,returnCode] = azSubprocess(cmd)
		nextDiskPassword = output
		# STEP 1B: Encrypt and encode the new password:
		messageForEncryption = 'FileVault Disk Password: ' + nextDiskPassword
		nextDiskPasswordE = encryptWithPubKey(messageForEncryption.encode('ascii','replace'),pubKeyFilePath)
		# STEP 2A: Escrow new FileVault disk password in system keychain:
		escrowedNextDiskPassword = storePasswordInSystemKeychain('com.amazon.DiskPassword.next', 'FileVault Disk Password Candidate', nextDiskPassword)
		# STEP 2B: Escrow the encrypted form of the FileVault disk password in the history file:
		historyPrefsDict = azReadPlist(historyPrefsPath)
		historyPrefsDict['nextDiskPassword'] = nextDiskPasswordE
		azWritePlist(historyPrefsDict, historyPrefsPath)
		# Verify written:
		historyPrefsDict = azReadPlist(historyPrefsPath)
		if (historyPrefsDict['nextDiskPassword'] == nextDiskPasswordE) and (nextDiskPasswordE != 'invalid-message'):
			escrowedNextDiskPasswordE = True
			logger.info('Escrow: Escrowing detool history succeeded')
		else:
			logger.info('Escrow: Escrowing detool history failed')
	else:
		escrowedNextDiskPassword = False
		escrowedNextDiskPasswordE = False
		logger.error('Escrow: Current disk password missing, cannot rotate disk password')
		# Return:
	return (escrowedNextDiskPassword and escrowedNextDiskPasswordE)

def rotateDiskPassword(bootVolumeUUID, userPassword, suppliedUnlockPassword, fileSystemType, apfsDiskUserEnabled):
## Rotation procedure that puts new Disk Passwords into operation.
	logger.info('rotateDiskPassword: Begining disk password rotation of encrypted contents')
	defaultDiskPassword = mainDictionary['fileVaultConfigDict']['defaultDiskPassword']
	historyPrefsPath = mainDictionary['fileVaultConfigDict']['historyPrefsPath']
	historyPrefsPathBackup = mainDictionary['fileVaultConfigDict']['historyPrefsPathBackup']
	# Default:
	storedCurrentPassword = False
	changedDiskPassword = False
	# STEP 1 - Read new and current disk passwords:
	newDiskPassword = getPasswordFromKeychain('com.amazon.DiskPassword.next',systemKeychainPath)
	currentDiskPassword = getPasswordFromKeychain('com.amazon.DiskPassword.current',systemKeychainPath)
	historyPrefsDict = azReadPlist(historyPrefsPath)
	# newDiskPasswordE key has to be present due to successful generateAndEscrowNextDiskPassword()
	newDiskPasswordE = historyPrefsDict['nextDiskPassword']
	# currentDiskPasswordE key may be missing; set to blank if not found.
	try:
		currentDiskPasswordE = historyPrefsDict['currentDiskPassword']
	except:
		currentDiskPasswordE = ''	
	# STEP 2 - Change the disk password:
	# Create an array of disk password candidates:  Order is:
	# 1st - Disk password in the system keychain (com.amazon.DiskPassword.current).
	# 2nd - Default disk password (newly imaged system?)
	# 3rd - A disk unlock or user password as entered by the user (via detool).
	unlockPasswordArray = [currentDiskPassword,defaultDiskPassword]
	if suppliedUnlockPassword != 'not-supplied':
		unlockPasswordArray.append(suppliedUnlockPassword)
	if userPassword != 'not-supplied':
		unlockPasswordArray.append(userPassword)
	# Try changing the disk password by authorizing with each password candidate:
	for anUnlockPassword in unlockPasswordArray:
		# It has been observed that the disk rotation gets performed with every execution of detool status
		# This may be problematic of ran multiple times concurently with 3 possible triggers being acme prefs, quarantine, and user interaction.
		time.sleep(15)
		csPasswdResult = diskutilChangeVolumePassword(bootVolumeUUID, anUnlockPassword, newDiskPassword, fileSystemType, apfsDiskUserEnabled)
		if csPasswdResult == 'success':
			changedDiskPassword = True
			break
	# STEP 3: Rotate disk passwords in the system keychain and history file:
	if changedDiskPassword:
		logger.info('rotateDiskPassword: Disk Password changed successfully, store data to history file')
		# Rotate keychain items:
		storedPreviousPassword = storePasswordInSystemKeychain('com.amazon.DiskPassword.previous', 'Previous FileVault Disk Password', currentDiskPassword)
		storedCurrentPassword = storePasswordInSystemKeychain('com.amazon.DiskPassword.current', 'FileVault Disk Password', newDiskPassword)
		# Update history file:
		nowPoint = datetime.datetime.utcnow()
		historyPrefsDict['previousDiskPassword'] = currentDiskPasswordE
		historyPrefsDict['currentDiskPassword'] = newDiskPasswordE
		historyPrefsDict['nextDiskPassword'] = ''
		historyPrefsDict['diskPasswordLastChanged'] = nowPoint
		azWritePlist(historyPrefsDict, historyPrefsPath)
		#backup new detool history file
		try:
			shutil.copy(historyPrefsPath,historyPrefsPathBackup)
		except:
			logger.error('rotateDiskPassword: Could not backup new detool history file')
	# Return - if storedCurrentPassword then changedDiskPassword:
	return storedCurrentPassword

def diskutilChangeVolumePassword(volumeUUID, currentDiskPassword, newDiskPassword, fileSystemType, apfsDiskUserEnabled):
	logger.info('diskutilChangeVolumePassword: executing diskutil change volume password')
	## Change the FileVault Disk Password given old and new ones.
	# Default:
	csPasswdResult = 'unknown-error'
	if fileSystemType == 'hfs':
		try:
			cmd = '/usr/sbin/diskutil'
			args = ['cs', 'changeVolumePassphrase', volumeUUID]
			# Run diskutil:
			child = pexpect.spawn(cmd, args, timeout=60)
			# Enter the current password:
			child.expect('Old passphrase:')
			child.sendline(currentDiskPassword)
			# Enter the new password twice:
			child.expect('New passphrase:')
			child.sendline(newDiskPassword)
			child.expect('Repeat new passphrase:')
			child.sendline(newDiskPassword)
			# Block on diskutil execution:
			child.read(size=-1)
			child.close()
			# Inspect diskutil output.
			if child.before.lower().find('logical volume passphrase has been changed') != -1:
				# Success looks like:
				# Started CoreStorage operation
				# Logical Volume passphrase has been changed
				# Core Storage LV UUID: CBA12345-1234-5678-A1B2-ZY12345AB987
				# Finished CoreStorage operation
				csPasswdResult = 'success'
			elif child.before.lower().find('invalid request') != -1:
				# If no disk password, output looks like:
				# Started CoreStorage operation
				# Error: -69886: Invalid request
				csPasswdResult = 'invalid-request'
			elif child.before.lower().find('unable to change the core storage passphrase') != -1:
				# If no disk password, output looks like:
				# Started CoreStorage operation
				# Error: -69725: Unable to change the Core Storage passphrase
				csPasswdResult = 'cannot-change'
			elif child.before.lower().find('69666') != -1:
				# Error: -69666 This Core Storage operation is not allowed on a sparse logical volume group
				# Disk is not finished encrypting with original password. Cannot rotate until its finished with encryption?
				csPasswdResult = 'cannot-change'
				logger.info('diskutilChangeVolumePassword: Cannot rotate intial disk password until encryption is finsished')
			else:
				csPasswdResult = 'other-error'
		except:
			ipcSendAndPrintMessage('diskutilChangeVolumePassword: HFS diskutil timed out or failed.',fromHelperSocketPath, azIdentifier)
	elif fileSystemType == 'apfs' and apfsDiskUserEnabled == True:
		try:
			# apfsdeviceidentifier is the bsd device name, the disk user is the cryptographic "user" for filevault now.
			# The disk "user" is also the same uuid as the apfs encrypted boot volume
			cmd = '/usr/sbin/diskutil'
			args = ['apfs', 'changePassphrase', '/', '-user', 'disk']
			# Run diskutil:
			child = pexpect.spawn(cmd, args, timeout=60)
			# Enter the current password:
			child.expect('Old passphrase for user')
			child.sendline(currentDiskPassword)
			# Enter the new password twice:
			child.expect('New passphrase:')
			child.sendline(newDiskPassword)
			child.expect('Repeat new passphrase:')
			child.sendline(newDiskPassword)
			# Block on diskutil execution:
			child.read(size=-1)
			child.close()
			# Inspect diskutil output.
			if child.before.lower().find('passphrase changed successfully') != -1:
				# Success looks like:
				# Changing passphrase for user VOLUMEUIUD on apfs volume disk1s
				# Passphrase changed successfully
				csPasswdResult = 'success'
			elif child.before.lower().find('passphrase entry error: no passphrase specified') != -1:
				# If no disk password provided, output looks like:
				# Passphrase entry error: no passphrase specified
				csPasswdResult = 'invalid-request'
			elif child.before.lower().find('error') != -1:
				# If password is incorrect
				# Changing password for cyrptographic user on apfs volume: unable to change the password for the givent apfs volume (-69590)
				# Error changing passphrase for cryptographic user
				csPasswdResult = 'cannot-change'
			else:
				csPasswdResult = 'other-error'
		except:
			ipcSendAndPrintMessage('diskutilChangeVolumePassword: diskutil APFS timed out or failed.',fromHelperSocketPath, azIdentifier)
	# Return:
	return csPasswdResult

def getFileVaultStatus(userName):
	logger.info('getFilevaultStatus: Determining filevault status')
	## Gather relevant status information for the computer's requirements and FileVault states.
	defaultDiskPassword = mainDictionary['fileVaultConfigDict']['defaultDiskPassword']
	# Identify the Mac:
	computerType = identifyComputerType()
	# Determine if FileVault is necessary:
	bootVolumeEncryptionRequired, exemptByIdentifier, exemptBySemaphore = isDiskEncryptionRequired(computerType)
	# Determine if FileVault is enabled:
	[bootVolumeEncryptionEnabled, bootVolumeUUID, bootVolumeFamilyUUID, bootVolumeConversionStatus, bootVolumeFamilyEncType, fileSystemType, apfsDiskUserEnabled] = bootVolumeFileVaultStatus()
	# Determine requirement status:
	if not bootVolumeEncryptionRequired:
		status_required = False
	else:
		status_required = True
	# Determine encryption status:
	if not bootVolumeEncryptionEnabled:
		status_encryption = False
		status_disk_password = 'encryption-not-enabled'
	else:
		status_encryption = True
		# Get FileVault disk password status:
		# Try to change the disk password from the default to the default.
		# This serves as a negative test for having the default disk password.
		if fileSystemType == 'hfs' or fileSystemType == 'apfs' and apfsDiskUserEnabled == True:
			csPasswdResult = diskutilChangeVolumePassword(bootVolumeUUID, defaultDiskPassword, defaultDiskPassword, fileSystemType, apfsDiskUserEnabled)
			if csPasswdResult == 'success':
				status_disk_password = 'default-password'
			elif csPasswdResult == 'cannot-change':
				status_disk_password = 'not-default-password'
			elif csPasswdResult == 'invalid-request':
				status_disk_password = 'no-disk-password'
			else:
				status_disk_password = 'unknown-state'
		elif fileSystemType == 'apfs' and apfsDiskUserEnabled == False:
			status_disk_password = 'admin-provisioned'
		logger.info('getFileVaultStatus: Status Disk Password ' + str(status_disk_password))
	# Get FileVault user status:
	[diskUnlockUserList, requestedUserIsValid, requestedUserCanUnlockDisk] = fileVaultUserStatus(userName,fileSystemType, apfsDiskUserEnabled)
	# Determine user list status:
	if not diskUnlockUserList:
		# No users can unlock the disk:
		status_user_list = False
	else:
		# One or more users can unlock the disk:
		status_user_list = True	
	# Determine current user status:
	if not requestedUserIsValid:
		# No valid current user:
		status_requested_user = 'requested-user-not-valid'
	else:
		# Valid current user:
		if not requestedUserCanUnlockDisk:
			status_requested_user = 'valid-not-provisioned'
		else:
			status_requested_user = 'valid-provisioned'	
	# Return:
	return status_required, status_encryption, status_disk_password, status_user_list, status_requested_user, fileSystemType, apfsDiskUserEnabled, [computerType, exemptByIdentifier, exemptBySemaphore, bootVolumeUUID, bootVolumeFamilyUUID, bootVolumeConversionStatus, bootVolumeFamilyEncType, diskUnlockUserList]

def main():
	## MAIN
	# Open mainDictionary:
	global mainDictionary
	mainDictionary = azLoadMainDictionary()
	initialSecureTokenAdmin = mainDictionary['fileVaultConfigDict']['initialSecureTokenAdmin']
	global systemKeychainPath
	systemKeychainPath = '/Library/Keychains/System.keychain'
	global loginWindowPlist
	loginWindowPlist = '/Library/Preferences/com.apple.loginwindow.plist'
	# Sockets paths:
	toHelperSocketPath = mainDictionary['socketPaths']['detool']['toHelper']
	# Prefs path:
	assistantPrefsPath = mainDictionary['prefsFile'].replace('~','').replace('__azIdentifier__',azIdentifier).replace('.helper','')
	# Default states for some variables:
	problem = 'no-problem'
	requestReboot = False
	lastCheck = datetime.datetime.utcnow()
	# Check for root.
	[haveRootUser, userHomePath] = validateUserIsRoot()
	if not haveRootUser:
		# Root required for helper.
		logger.error('This helper must be run by root.')
	else:
		# Try to get message from detool and validate it.  Assume invalid message.
		validMessage = False
		logger.info('Waiting for message from detool...')
		[shouldRecieveMessage, messageArray] = ipcReceive(toHelperSocketPath,300)
		if not shouldRecieveMessage:
			problem = 'helper-already-running'
			logger.error('Another instance of this helper is active.  Exiting.')
		else:
			try:
				# Get socket path for replying to detool:
				global fromHelperSocketPath
				fromHelperSocketPath = messageArray[0]
				action = messageArray[1]
				# We always receive userName, userPassword, and suppliedUnlockPassword even though they may be 'not-supplied.'
				userName = messageArray[2]
				userPassword = messageArray[3]
				suppliedUnlockPassword = messageArray[4] 
				validMessage = True
			except:
				logger.error('Did not receive valid message from detool.  Exiting.')
		# Check message:
		if not validMessage:
			problem = 'invalid-message'
			logger.error('Invalid message or no response from detool.')
		else:
			# Message is valid - do initial status checks:
			[status_required, status_encryption, status_disk_password, status_user_list, status_requested_user, fileSystemType, apfsDiskUserEnabled, additionalDetails] = getFileVaultStatus(userName)
			ipcSendAndPrintMessage('FileVault required (startup disk): ' + str(status_required)  + '.',fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('FileVault enabled (startup disk): ' + str(status_encryption)  + '.',fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('Disk Password status: ' + status_disk_password  + '.',fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('At least one user can unlock disk: ' + str(status_user_list)  + '.',fromHelperSocketPath, azIdentifier)
			ipcSendAndPrintMessage('Requested user status: ' + status_requested_user  + '.',fromHelperSocketPath, azIdentifier)
			if action != 'status':
				# CONFIGURE: Direct the FileVault configuration to meet Amazon policy:
				if action == 'configure':
					if not status_required:
						ipcSendAndPrintMessage('FileVault is not required for this Mac.',fromHelperSocketPath, azIdentifier)
					else:
						# FileVault is reqired:
						# CONFIGURATION ACTION 1: If FileVault is off, enable it:
						if not status_encryption:
							ipcSendAndPrintMessage('Enabling FileVault encryption on the startup disk...',fromHelperSocketPath, azIdentifier)
							# Enable FileVault:
							conversionStarted = enableFileVaultOnBootVolume(fileSystemType)
							if not conversionStarted:
								# Update problem.
								problem = 'could-not-enable-filevault'
								ipcSendAndPrintMessage('ERROR: Could not turn on FileVault for the startup disk!',fromHelperSocketPath, azIdentifier)
							else:
								# Restart required after CoreStorage conversion!
								requestReboot = True
								ipcSendAndPrintMessage('FileVault appears to have been enabled.  A restart is now required!',fromHelperSocketPath, azIdentifier)
						# CONFIGURATION ACTION 2: Handle provisioning of user accounts.
						# Reconsider status_encryption's value (in case FileVault was just enabled).
						if status_encryption:
							ipcSendAndPrintMessage('Encryption is already enabled on the startup disk.',fromHelperSocketPath, azIdentifier)
							# 2A: Requested user is not valid:
							if status_requested_user == 'requested-user-not-valid':
								if userName == 'try-session-user':
									ipcSendAndPrintMessage('No Aqua session user.',fromHelperSocketPath, azIdentifier)
								else:
									ipcSendAndPrintMessage('User ' + userName + ' is not eligible to unlock the disk.',fromHelperSocketPath, azIdentifier)
							# 2B: Requested user is already provisioned:
							elif status_requested_user == 'valid-provisioned':
								if userName == 'try-session-user':
									ipcSendAndPrintMessage('Session user already provisioned to unlock the disk.',fromHelperSocketPath, azIdentifier)
								else:
									ipcSendAndPrintMessage('User ' + userName + ' already provisioned to unlock the disk.',fromHelperSocketPath, azIdentifier)
							# 2C: Requested user is eligible to be provisioned:
							else: # status_requested_user = 'valid-not-provisioned'
								userAdded = False
								# User name and password must be specified here; if not, display an error:
								if (userName == 'try-session-user') or (userPassword == 'not-supplied'):
									ipcSendAndPrintMessage('ERROR: User information must be specified when adding a user.',fromHelperSocketPath, azIdentifier)
								else:
									userAdded = addUserToFileVault(userName, userPassword, suppliedUnlockPassword,fileSystemType, apfsDiskUserEnabled)
								if not userAdded:
									# Update problem.
									problem = 'could-not-add-user'
								else:
									# Verify again so that step 3 has an accurate user list.
									ipcSendAndPrintMessage('User list appears to have changed.  Re-running verificiation routine...',fromHelperSocketPath, azIdentifier)
									[status_required, status_encryption, status_disk_password, status_user_list, status_requested_user, fileSystemType, apfsDiskUserEnabled, additionalDetails] = getFileVaultStatus(userName)
							# CONFIGURATION ACTION 3: Manage the disk password.
							if shouldSetDiskPassword(status_disk_password, status_user_list, fileSystemType, apfsDiskUserEnabled):
								ipcSendAndPrintMessage('Disk password should be changed.',fromHelperSocketPath, azIdentifier)
								# Generate a disk password and escrow it in the system keychain:
								#logger.info(status_encryption)
								escrowedNextDiskPassword = generateAndEscrowNextDiskPassword(status_encryption, status_disk_password)
								if not escrowedNextDiskPassword:
									# Update problem.
									ipcSendAndPrintMessage('ERROR: Could not escrow new disk password materials.',fromHelperSocketPath, azIdentifier)
									problem = 'error-escrowing-disk-password'
								else:
									ipcSendAndPrintMessage('Escrowed new disk password materials.',fromHelperSocketPath, azIdentifier)
									# If the new password has been escrowed, try to update the disk password:
									bootVolumeUUID = additionalDetails[3]
									ipcSendAndPrintMessage('Attempting to rotate disk password for '+str(bootVolumeUUID)+'.',fromHelperSocketPath, azIdentifier)
									rotatedDiskPassword = rotateDiskPassword(bootVolumeUUID, userPassword, suppliedUnlockPassword, fileSystemType, apfsDiskUserEnabled)
									if not rotatedDiskPassword:
										# Update problem.
										ipcSendAndPrintMessage('ERROR: Could not rotate disk password.',fromHelperSocketPath, azIdentifier)
										problem = 'error-rotating-disk-password'
									else:
										ipcSendAndPrintMessage('Rotated disk password successfully, Updating Jamf Inventory',fromHelperSocketPath, azIdentifier)
										#sleeping for 15 seconds before we upload the inventory to ensure all detool data is written
										time.sleep(15)
										cmd = ['/usr/local/bin/jamf','recon' ]
										[output,returnCode] = azSubprocess(cmd)
							else:
								logger.info('Disk password rotation unnecessary')
				# Final verification:
				ipcSendAndPrintMessage('Running final verification...',fromHelperSocketPath, azIdentifier)
				[status_required, status_encryption, status_disk_password, status_user_list, status_requested_user, fileSystemType, apfsDiskUserEnabled, additionalDetails] = getFileVaultStatus(userName)
				ipcSendAndPrintMessage('FileVault required (startup disk): ' + str(status_required)  + '.',fromHelperSocketPath, azIdentifier)
				ipcSendAndPrintMessage('FileVault enabled (startup disk): ' + str(status_encryption)  + '.',fromHelperSocketPath, azIdentifier)
				ipcSendAndPrintMessage('Disk Password status: ' + status_disk_password  + '.',fromHelperSocketPath, azIdentifier)
				ipcSendAndPrintMessage('At least one user can unlock disk: ' + str(status_user_list)  + '.',fromHelperSocketPath, azIdentifier)
				ipcSendAndPrintMessage('Requested user status: ' + status_requested_user  + '.',fromHelperSocketPath, azIdentifier)
				# Blank these variables:
				userName = ''
				userPassword = ''
				suppliedUnlockPassword = ''
			# Tell unprivilged tool that this helper is done:
			ipcSendAndPrintMessage('__closeSocket__',fromHelperSocketPath, azIdentifier)
		# Set prefs keys and update prefs file.
		assistantPrefsDict = {}
		assistantPrefsDict['lastCheck'] = lastCheck
		assistantPrefsDict['problem'] = problem
		assistantPrefsDict['requestReboot'] = requestReboot
		# Can only set status information if we got a valid message.
		try:
			assistantPrefsDict['status_required'] = status_required
			assistantPrefsDict['status_encryption'] = status_encryption
			assistantPrefsDict['status_disk_password'] = status_disk_password
			assistantPrefsDict['status_user_list'] = status_user_list
			assistantPrefsDict['status_requested_user'] = status_requested_user
			assistantPrefsDetailsDict = {}
			assistantPrefsDetailsDict['computerType'] = additionalDetails[0]
			assistantPrefsDetailsDict['exemptByIdentifier'] = additionalDetails[1]
			assistantPrefsDetailsDict['exemptBySemaphore'] = additionalDetails[2]
			assistantPrefsDetailsDict['bootVolumeUUID'] = additionalDetails[3]
			assistantPrefsDetailsDict['bootVolumeFamilyUUID'] = additionalDetails[4]
			assistantPrefsDetailsDict['bootVolumeConversionStatus'] = additionalDetails[5]
			assistantPrefsDetailsDict['bootVolumeFamilyEncType'] = additionalDetails[6]
			assistantPrefsDetailsDict['diskUnlockUserList'] = additionalDetails[7]
			assistantPrefsDict['details'] = assistantPrefsDetailsDict
		except:
			logger.debug('No status to report.  Refer to problems key in ' + assistantPrefsPath +'.')
		azWritePlist(assistantPrefsDict, assistantPrefsPath)

if __name__ == '__main__':
	global azIdentifier
	global logger

	azIdentifier = 'com.amazon.acme.helper.detool'
	logger = azLogger(azIdentifier)
	try:
		main()
	except:
		logger.error('Generic exception.')
		
